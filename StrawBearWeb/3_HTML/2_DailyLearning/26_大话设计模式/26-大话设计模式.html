<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="UTF-8">
        <meta name="StrawBear" content="width=device-width,initial-scale=1.0">
        <title>26-大话设计模式</title>
        <link rel="stylesheet" href="../../../1_CSS/basicStyle.css">
    </head>   
    <body>
        <aside>
            <ul>
                <li><a href="#0">0.契子 培训实习生-面向对象基础</a>
                    <ul>
                        <li><a href="#1.1">1.1 安装基础软件</a></li>
                    </ul>
                </li>
                <li><a href="#1">1.代码无措就是优?-简单工厂模式</a></li>
                <li><a href="#2">2.商场促销-策略模式</a></li>
                <li><a href="#3">3.电子阅读器vs手机-单一职责原则</a></li>
                <li><a href="#4">4.考研求职两不误-开放封闭原则</a></li>
                <li><a href="#5">5.会修电脑不会修收音机?-依赖倒置原则</a></li>
                <li><a href="#6">6.穿什么有这么重要?-装饰模式</a></li>
                <li><a href="#7">7.为别人做嫁衣-代理模式</a></li>
                <li><a href="#8">8.工厂制造细节无须知-工厂方法模式</a></li>
                <li><a href="#9">9.简历复印-原型模式</a></li>
                <li><a href="#10">10.考题抄错会做也白搭-模板方法模式</a></li>
                <li><a href="#11">11.无熟人难办事?-迪米特法则</a></li>
                <li><a href="#12">12.牛市股票还会亏钱?-外观模式</a></li>
                <li><a href="#13">13.好菜每回味不同-建造者模式</a></li>
                <li><a href="#14">14.老板回来,我不知道-观察者模式</a></li>
                <li><a href="#15">15.就不能不换DB吗?-抽象工厂模式</a></li>
                <li><a href="#16">16.无尽加班何时休-状态模式</a></li>
                <li><a href="#17">17.在NBA我需要翻译-适配器模式</a></li>
                <li><a href="#18">18.如果再回到从前-备忘录模式</a></li>
                <li><a href="#19">19.分公司=-部分-组合模式</a></li>
                <li><a href="#20">20.想走?可以!先买票-迭代器模式</a></li>
                <li><a href="#21">21.有些类也需要计划生育-单例模式</a></li>
                <li><a href="#22">22.手机软件何时统一-桥接模式</a></li>
                <li><a href="#23">23.烤羊肉串引来的思考-命令模式</a></li>
                <li><a href="#24">24.加薪非要老总批?-责任链模式</a></li>
                <li><a href="#25">25.世界需要和平-中介者模式</a></li>
                <li><a href="#26">26.项目多也别傻做-享元模式</a></li>
                <li><a href="#27">27.其实你不懂老板的心-解释器模式</a></li>
                <li><a href="#28">28.男人和女人-访问者模式</a></li>
                <li><a href="#29">29.OOTV杯超级模式大赛-模式总结</a></li>
            </ul>
        </aside>
        <nav>
            <a href="#20240603"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240603:冒险岛的僵尸蘑菇和刺蘑菇<br>
            在冒险岛世界当中,每个蘑菇怪都是一个<strong>对象</strong>有独特的属性和行为,具有<strong>相同属性和特性</strong>的蘑菇被分成了一个<strong>类</strong>,
            例如刺蘑菇<img class="icon" src="Resources/img/chapter0/刺蘑菇.png">都有刺头属性,他们的行为都是走,僵尸蘑菇<img class="icon" src="Resources/img/chapter0/僵尸蘑菇.png">都有额头的符箓,行为是跳动.<br>
            <a href="#20240625"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240625:构造函数,属性<br>
            冒险岛当中不同的地图有不同的<strong>怪物构造器</strong>,通过不同构造器初始化不同的怪物,僵尸蘑菇携带的金钱镖,符篆等等可以掉落装备以
            <strong>属性</strong>的方式存储,玩家可以看到,但是不能设置,所以是<strong>只读属性</strong>,还有一些隐藏的根据玩家氪金多少来提高爆率的
            设置则通过<strong>字段</strong>存储,字段是不公开的变量<br>
            <a href="#20240703"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240703:继承,多态,抽象类,重构<br>
            <strong>继承描述的是共享</strong>的关系,例如刺蘑菇Boss在继承刺蘑菇基类的情况下多了自己独有的掉落,多态则是所有蘑菇基类的移动方式,刺蘑菇,绿蘑菇,僵尸蘑菇都有不同的表现方式,
            抽象类指的是没有具体实例的对象,例如蘑菇,只是一大堆<strong>具体实例的抽象集合</strong>,是一个<strong>概念</strong>,所以蘑菇是抽象类,重构则是发现不变的部分提炼概念,发现变化的部分多态实现的过程<br>

        </nav>
        <header><p class="header">26-大话设计模式</p></header>
        <article id="0"><p class="chapter">0.契子 培训实习生-面向对象基础</p>
            <p class="timeStamp" id="20240603">20240603学习-对象和类</p>
            <section id="0.1"><p class="section">0.1 培训实习生</p> 
                <div>
                    <p>
                        情景设定是小菜教新入职的大学生史熙<br>
                    </p>
                </div>  
            </section>
            <section id="0.2"><p class="section">0.2 类与实例</p>
                <div>
                    <p class="paragraph">示例</p>
                    <p>
                        问题1:实现猫叫<br>
                        解决1:直接使用print打印<br>
                        <br>
                        问题2:如果想要叫很多声,总不能复制多几行print吧<br>
                        解决2:为了方便复用,把喊叫封装到一个方法,调用方法就可以了<br>
                        <br>
                        问题3:如果其他地方也需要猫叫怎么办<br>
                        解决3:使用了public进行公开,这样其他地方也可以调用了<br>
                        <br>
                        问题4:在我们当前的test类当中调用猫叫不太合适,也不方便理解<br>
                        解决4:给当前的类换个名字,叫做Cat,这样在Cat猫类找到猫叫方法就很合适了.<br>
                    </p>
                    <p class="paragraph">概念</p>
                    <p>
                        对象是一个自包含的实体,用一组可识别的特性和行为来标识<br>
                        <br>
                        类就是具有相同的属性和功能的对象的抽象的集合.<br>
                    </p>
                    <p class="paragraph">代码</p>
                    <p>
                        <figure>
                            <img src="Resources/img/chapter0/001Cat.png" alt="001Cat">
                            <p>
                                几个核心概念,声明,定义<br>
                            </p>
                        </figure>
                    </p>
                </div>
            </section>   
            <p class="timeStamp" id="20240625">20240625学习</p>
            <section id="0.3"><p class="section">0.3 构造方法</p>
                <div>
                    <p class="paragraph">构造方法的定义</p>
                    <figure>
                        <img src="Resources/img/chapter0/002.png" alt="构造方法的定义">
                        <p>
                            构造方法:构造方法又叫做构造函数,其实就是对类进行初始化.<br>
                        </p>
                    </figure>
                    <p class="paragraph">语法</p>
                    <figure>
                        <img src="Resources/img/chapter0/003.png" alt="语法特点">
                        <p>
                            1.构造方法与类同名,无返回值,在new的时候调用.<br>
                            2.所有的类都有默认的构造方法,系统会默认生成<br>
                            3.当我们自定义构造方法,原来的默认构造方法就不会生成了.<br>
                        </p>
                    </figure>
                </div>
            </section>              
            <section id="0.4"><p class="section">0.4 方法重载</p>
                <div>
                    <figure>
                        <img src="Resources/img/chapter0/004方法重载.png" alt="方法重载">
                        <p>
                            方法重载提供了创建同名的多个方法的能力,但这些方法需要使用不同的参数类型.<br>
                            方法名必须相同,参数必须不同(同名异参),这样就可以在不改变原有方法的基础上,适应其他的参数.<br>
                        </p>
                    </figure>
                </div>
            </section>              
            <section id="0.5"><p class="section">0.5 属性与修饰符</p>
                <div>
                    <figure>
                        <img src="Resources/img/chapter0/005属性.png" alt="属性">
                        <p>
                            属性是一个方法或一对方法,即属性适合于以字段的方式使用方法调用的场合.<br>
                            字段是存储类要满足其设计所需要的数据,字段是与类相关的变量.<br>
                            属性是<strong>公有</strong>的(不公开)变量,字段是<strong>私有</strong>的变量<br>
                        </p>
                    </figure>                                                  
                </div>
            </section>              
            <section id="0.6"><p class="section">0.6 封装</p>
                <div>
                    <p>
                        封装:每个对象都包含它能进行操作所需要的<strong>所有信息</strong>,这个特性称为封装,因此对象<strong>不必依赖其他对象</strong>来完成自己的操作.<br>
                        封装的好处<br>
                        1.良好的封装减少耦合(依赖其他对象就是耦合)<br>
                        2.类内部的实现可以自由地修改(不会引起连锁反应)<br>
                        3.类具有清晰的对外接口.<br>
                    </p>
                </div>
            </section>              
            <p class="timeStamp" id="20240703">20240703学习</p>
            <section id="0.7"><p class="section">0.7 继承</p>
                <div><p class="paragraph">什么是继承?</p>
                    对象的继承表明了一种"<strong>is a</strong>"关系,如果两个对象可以描述为B是A,那么B就可以继承A.<br>
                    继承者B可以认为是A的<strong>特殊化</strong>,不但具备A的全部功能,还有其他的<strong>特性</strong><br>
                    这是一种<strong>共享</strong>部分的定义<br>
                </div>
                <div><p class="paragraph">继承的特性</p>
                    三个特性<br>
                    1.子类拥有父类<strong>非private</strong>的属性和功能(public,protected,internal,file)<br>
                    2.子类具有自己<strong>独特</strong>的属性和功能(父类没有)<br>
                    3.子类还可以以自己的方式实现父类的功能(<strong>覆盖重写</strong>)<br>
                </div>
                <div><p class="paragraph">如何调用父类</p>
                    java当中子类通过<strong>base关键字</strong>来调用从父类继承的方法属性,构造函数则<strong>不能继承</strong>,只能调用(因为初始化是针对的父类的,在子类这里不能通用)<br>
                </div>
                <div><p class="paragraph">继承的优缺点</p>
                    优点:<br>
                    继承使得所有子类公共的部分都放在了父类,代码得到了<strong>共享</strong>,<strong>避免了重复</strong>,这也使得修改或扩展继承都相对变得容易了<br>
                    缺点:<br>
                    继承的缺点是当父类变化,子类不得不跟着一起变,继承会<strong>破坏封装</strong>,父类实现的细节会暴露给子类,是一种类之间的<strong>强耦合</strong>关系,子类依赖于父类<br>
                </div>
            </section>              
            <section id="0.8"><p class="section">0.8 多态</p>
                <div><p class="paragraph">段落</p>
                    <figure>
                        <img src="Resources/img/chapter0/006多态.png" alt="多态">
                        <p>
                            多态表示不同的对象可以执行<strong>相同的动作</strong>,但是他们有<strong>自己的实现</strong>代码来执行.<br>
                            示例是鸟类共同的方法移动Move<br>
                            但是不同的鸟类采用了完全不一样的方法来实现移动,这就是覆写Override<br>
                        </p>
                    </figure>
                </div>
                <div><p class="paragraph">多态的特性</p>
                    1.子类以父类的方式出现(上面的例子来说,都是实现移动这个父类的方法)<br>
                    2.子类在工作时以自己的方式来实现(不同的移动方式)<br>
                    3.子类以父类的身份出现的时候,就不能使用自己特有的这些父类没有的方法和属性了(不然就穿帮了)<br>
                </div>
                <div><p class="paragraph">多态的实现</p>
                    <figure>
                        <img src="Resources/img/chapter0/007覆写.png" alt="覆写">
                        <p>
                            子类通过@override关键字,覆写父类的实现.<br>
                        </p>
                    </figure>
                </div>
            </section>              
            <section id="0.9"><p class="section">0.9 重构</p>
                <div><p class="paragraph">段落</p>
                    <figure>
                        <img src="Resources/img/chapter0/008重构.png" alt="重构">
                        <p>
                            重构就是这种发现<strong>重复</strong>代码->提炼到父对象->发现<strong>变化</strong>代码->提炼成方法通过多态让子类实现<br>
                        </p>
                    </figure>
                </div>
            </section>              
            <section id="0.10"><p class="section">0.10 抽象类</p>
                <div><p class="paragraph">抽象类的概念</p>
                    抽象类是实例化没有任何意义的父类<br>
                </div>
                <div><p class="paragraph">抽象类的实现</p>
                    通过在class关键字前面增加abstract关键字类声明为抽象类或抽象方法<br>
                </div>
                <div><p class="paragraph">抽象类的特性</p>
                    1.抽象类<strong>不能实例化</strong>(因为没有实际的对象)<br>
                    2.抽象方法是子类<strong>必须重写</strong>的方法(没有默认实现)<br>
                    3.如果类中包含抽象方法,就必须定义为抽象类.<br>
                </div>
                <div><p class="paragraph">抽象类的作用</p>
                    抽象类通常代表一个抽象概念,提供一个继承的出发点,通常树叶节点应该是<strong>具体类</strong>,树枝节点则均是<strong>抽象类</strong>.<br>
                </div>
            </section>              
            <section id="0.11"><p class="section">0.11 接口</p></section>              
            <section id="0.12"><p class="section">0.12 集合</p></section>              
            <section id="0.13"><p class="section">0.13 泛型</p></section>              
            <section id="0.14"><p class="section">0.14 客套</p></section>              
        </article>
        <article id="1"><p class="chapter">1.代码无措就是优?-简单工厂模式</p></article>
        <article id="2"><p class="chapter">2.商场促销-策略模式</p></article>
        <article id="3"><p class="chapter">3.电子阅读器vs手机-单一职责原则</p></article>
        <article id="4"><p class="chapter">4.考研求职两不误-开放封闭原则</p></article>
        <article id="5"><p class="chapter">5.会修电脑不会修收音机?-依赖倒置原则</p></article>
        <article id="6"><p class="chapter">6.穿什么有这么重要?-装饰模式</p></article>
        <article id="7"><p class="chapter">7.为别人做嫁衣-代理模式</p></article>
        <article id="8"><p class="chapter">8.工厂制造细节无须知-工厂方法模式</p></article>
        <article id="9"><p class="chapter">9.简历复印-原型模式</p></article>
        <article id="10"><p class="chapter">10.考题抄错会做也白搭-模板方法模式</p></article>
        <article id="11"><p class="chapter">11.无熟人难办事?-迪米特法则</p></article>
        <article id="12"><p class="chapter">12.牛市股票还会亏钱?-外观模式</p></article>
        <article id="13"><p class="chapter">13.好菜每回味不同-建造者模式</p></article>
        <article id="14"><p class="chapter">14.老板回来,我不知道-观察者模式</p></article>
        <article id="15"><p class="chapter">15.就不能不换DB吗?-抽象工厂模式</p></article>
        <article id="16"><p class="chapter">16.无尽加班何时休-状态模式</p></article>
        <article id="17"><p class="chapter">17.在NBA我需要翻译-适配器模式</p></article>
        <article id="18"><p class="chapter">18.如果再回到从前-备忘录模式</p></article>
        <article id="19"><p class="chapter">19.分公司=-部分-组合模式</p></article>
        <article id="20"><p class="chapter">20.想走?可以!先买票-迭代器模式</p></article>
        <article id="21"><p class="chapter">21.有些类也需要计划生育-单例模式</p></article>
        <article id="22"><p class="chapter">22.手机软件何时统一-桥接模式</p></article>
        <article id="23"><p class="chapter">23.烤羊肉串引来的思考-命令模式</p></article>
        <article id="24"><p class="chapter">24.加薪非要老总批?-责任链模式</p></article>
        <article id="25"><p class="chapter">25.世界需要和平-中介者模式</p></article>
        <article id="26"><p class="chapter">26.项目多也别傻做-享元模式</p></article>
        <article id="27"><p class="chapter">27.其实你不懂老板的心-解释器模式</p></article>
        <article id="28"><p class="chapter">28.男人和女人-访问者模式</p></article>
        <article id="29"><p class="chapter">29.OOTV杯超级模式大赛-模式总结</p></article>
        <footer><a href="../../../../index.html">首页</a></footer>
        <script>
                // 读取存储的滚动位置并滚动到该位置  
            const scrollPositionKey = 'scrollPosition';  // 定义滚动位置变量
            const storedScrollPosition = localStorage.getItem(scrollPositionKey); // localStorage是存在用户设备上
            
            window.onload = function()  // 读取窗口的时候就回滚到上次位置
            {
                if (storedScrollPosition)  // 如果滚动位置存在 
                {  
                    window.scrollTo(0, parseInt(storedScrollPosition)); // 滚动到这个位置 
                } 
            } 
            
            // 监听滚动事件并存储位置  
            window.addEventListener('scroll', () => 
            {  
                const scrollPosition = window.scrollY || window.pageYOffset || document.body.scrollTop + (document.documentElement && document.documentElement.scrollTop || 0);  
                localStorage.setItem(scrollPositionKey, scrollPosition);  
            });
        </script>
    </body>
</html>
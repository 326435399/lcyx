<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="UTF-8">
        <meta name="StrawBear" content="width=device-width,initial-scale=1.0">
        <title>26-大话设计模式</title>
        <link rel="stylesheet" href="../../../1_CSS/basicStyle.css">
    </head>   
    <body>
        <aside>
            <ul>
                <li><a href="#0">0.契子 培训实习生-面向对象基础</a>
                    <ul>
                        <li><a href="#1.1">1.1 安装基础软件</a></li>
                    </ul>
                </li>
                <li><a href="#1">1.代码无措就是优?-简单工厂模式</a></li>
                <li><a href="#2">2.商场促销-策略模式</a></li>
                <li><a href="#3">3.电子阅读器vs手机-单一职责原则</a></li>
                <li><a href="#4">4.考研求职两不误-开放封闭原则</a></li>
                <li><a href="#5">5.会修电脑不会修收音机?-依赖倒置原则</a></li>
                <li><a href="#6">6.穿什么有这么重要?-装饰模式</a></li>
                <li><a href="#7">7.为别人做嫁衣-代理模式</a></li>
                <li><a href="#8">8.工厂制造细节无须知-工厂方法模式</a></li>
                <li><a href="#9">9.简历复印-原型模式</a></li>
                <li><a href="#10">10.考题抄错会做也白搭-模板方法模式</a></li>
                <li><a href="#11">11.无熟人难办事?-迪米特法则</a></li>
                <li><a href="#12">12.牛市股票还会亏钱?-外观模式</a></li>
                <li><a href="#13">13.好菜每回味不同-建造者模式</a></li>
                <li><a href="#14">14.老板回来,我不知道-观察者模式</a></li>
                <li><a href="#15">15.就不能不换DB吗?-抽象工厂模式</a></li>
                <li><a href="#16">16.无尽加班何时休-状态模式</a></li>
                <li><a href="#17">17.在NBA我需要翻译-适配器模式</a></li>
                <li><a href="#18">18.如果再回到从前-备忘录模式</a></li>
                <li><a href="#19">19.分公司=-部分-组合模式</a></li>
                <li><a href="#20">20.想走?可以!先买票-迭代器模式</a></li>
                <li><a href="#21">21.有些类也需要计划生育-单例模式</a></li>
                <li><a href="#22">22.手机软件何时统一-桥接模式</a></li>
                <li><a href="#23">23.烤羊肉串引来的思考-命令模式</a></li>
                <li><a href="#24">24.加薪非要老总批?-责任链模式</a></li>
                <li><a href="#25">25.世界需要和平-中介者模式</a></li>
                <li><a href="#26">26.项目多也别傻做-享元模式</a></li>
                <li><a href="#27">27.其实你不懂老板的心-解释器模式</a></li>
                <li><a href="#28">28.男人和女人-访问者模式</a></li>
                <li><a href="#29">29.OOTV杯超级模式大赛-模式总结</a></li>
            </ul>
        </aside>
        <nav>
            <a href="#20240603"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240603:冒险岛的僵尸蘑菇和刺蘑菇<br>
            在冒险岛世界当中,每个蘑菇怪都是一个<strong>对象</strong>有独特的属性和行为,具有<strong>相同属性和特性</strong>的蘑菇被分成了一个<strong>类</strong>,
            例如刺蘑菇<img class="icon" src="Resources/img/chapter0/刺蘑菇.png">都有刺头属性,他们的行为都是走,僵尸蘑菇<img class="icon" src="Resources/img/chapter0/僵尸蘑菇.png">都有额头的符箓,行为是跳动.<br>
            <a href="#20240625"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240625:构造函数,属性<br>
            冒险岛当中不同的地图有不同的<strong>怪物构造器</strong>,通过不同构造器初始化不同的怪物,僵尸蘑菇携带的金钱镖,符篆等等可以掉落装备以
            <strong>属性</strong>的方式存储,玩家可以看到,但是不能设置,所以是<strong>只读属性</strong>,还有一些隐藏的根据玩家氪金多少来提高爆率的
            设置则通过<strong>字段</strong>存储,字段是不公开的变量<br>
        </nav>
        <header><p class="header">26-大话设计模式</p></header>
        <article id="0"><p class="chapter">0.契子 培训实习生-面向对象基础</p>
            <p class="timeStamp" id="20240603">20240603学习-对象和类</p>
            <section id="0.1"><p class="section">0.1 培训实习生</p> 
                <div>
                    <p>
                        情景设定是小菜教新入职的大学生史熙<br>
                    </p>
                </div>  
            </section>
            <section id="0.2"><p class="section">0.2 类与实例</p>
                <div>
                    <p class="paragraph">示例</p>
                    <p>
                        问题1:实现猫叫<br>
                        解决1:直接使用print打印<br>
                        <br>
                        问题2:如果想要叫很多声,总不能复制多几行print吧<br>
                        解决2:为了方便复用,把喊叫封装到一个方法,调用方法就可以了<br>
                        <br>
                        问题3:如果其他地方也需要猫叫怎么办<br>
                        解决3:使用了public进行公开,这样其他地方也可以调用了<br>
                        <br>
                        问题4:在我们当前的test类当中调用猫叫不太合适,也不方便理解<br>
                        解决4:给当前的类换个名字,叫做Cat,这样在Cat猫类找到猫叫方法就很合适了.<br>
                    </p>
                    <p class="paragraph">概念</p>
                    <p>
                        对象是一个自包含的实体,用一组可识别的特性和行为来标识<br>
                        <br>
                        类就是具有相同的属性和功能的对象的抽象的集合.<br>
                    </p>
                    <p class="paragraph">代码</p>
                    <p>
                        <figure>
                            <img src="Resources/img/chapter0/001Cat.png" alt="001Cat">
                            <p>
                                几个核心概念,声明,定义<br>
                            </p>
                        </figure>
                    </p>
                </div>
            </section>   
            <p class="timeStamp" id="202406025">202406025学习</p>
            <section id="0.3"><p class="section">0.3 构造方法</p>
                <div>
                    <p class="paragraph">构造方法的定义</p>
                    <figure>
                        <img src="Resources/img/chapter0/002.png" alt="构造方法的定义">
                        <p>
                            构造方法:构造方法又叫做构造函数,其实就是对类进行初始化.<br>
                        </p>
                    </figure>
                    <p class="paragraph">语法</p>
                    <figure>
                        <img src="Resources/img/chapter0/003.png" alt="语法特点">
                        <p>
                            1.构造方法与类同名,无返回值,在new的时候调用.<br>
                            2.所有的类都有默认的构造方法,系统会默认生成<br>
                            3.当我们自定义构造方法,原来的默认构造方法就不会生成了.<br>
                        </p>
                    </figure>
                </div>
            </section>              
            <section id="0.4"><p class="section">0.4 方法重载</p>
                <div>
                    <figure>
                        <img src="Resources/img/chapter0/004方法重载.png" alt="方法重载">
                        <p>
                            方法重载提供了创建同名的多个方法的能力,但这些方法需要使用不同的参数类型.<br>
                            方法名必须相同,参数必须不同(同名异参),这样就可以在不改变原有方法的基础上,适应其他的参数.<br>
                        </p>
                    </figure>
                </div>
            </section>              
            <section id="0.5"><p class="section">0.5 属性与修饰符</p>
                <div>
                    <figure>
                        <img src="Resources/img/chapter0/005属性.png" alt="属性">
                        <p>
                            属性是一个方法或一对方法,即属性适合于以字段的方式使用方法调用的场合.<br>
                            字段是存储类要满足其设计所需要的数据,字段是与类相关的变量.<br>
                            属性是<strong>公有</strong>的(不公开)变量,字段是<strong>私有</strong>的变量<br>
                        </p>
                    </figure>                                                  
                </div>
            </section>              
            <section id="0.6"><p class="section">0.6 封装</p>
                <div>
                    <p>
                        封装:每个对象都包含它能进行操作所需要的<strong>所有信息</strong>,这个特性称为封装,因此对象<strong>不必依赖其他对象</strong>来完成自己的操作.<br>
                        封装的好处<br>
                        1.良好的封装减少耦合(依赖其他对象就是耦合)<br>
                        2.类内部的实现可以自由地修改(不会引起连锁反应)<br>
                        3.类具有清晰的对外接口.<br>
                    </p>
                </div>
            </section>              
            <section id="0.7"><p class="section">0.7 继承</p></section>              
            <section id="0.8"><p class="section">0.8 多态</p></section>              
            <section id="0.9"><p class="section">0.9 重构</p></section>              
            <section id="0.10"><p class="section">0.10 抽象类</p></section>              
            <section id="0.11"><p class="section">0.11 接口</p></section>              
            <section id="0.12"><p class="section">0.12 集合</p></section>              
            <section id="0.13"><p class="section">0.13 泛型</p></section>              
            <section id="0.14"><p class="section">0.14 客套</p></section>              
        </article>
        <article id="1"><p class="chapter">1.代码无措就是优?-简单工厂模式</p></article>
        <article id="2"><p class="chapter">2.商场促销-策略模式</p></article>
        <article id="3"><p class="chapter">3.电子阅读器vs手机-单一职责原则</p></article>
        <article id="4"><p class="chapter">4.考研求职两不误-开放封闭原则</p></article>
        <article id="5"><p class="chapter">5.会修电脑不会修收音机?-依赖倒置原则</p></article>
        <article id="6"><p class="chapter">6.穿什么有这么重要?-装饰模式</p></article>
        <article id="7"><p class="chapter">7.为别人做嫁衣-代理模式</p></article>
        <article id="8"><p class="chapter">8.工厂制造细节无须知-工厂方法模式</p></article>
        <article id="9"><p class="chapter">9.简历复印-原型模式</p></article>
        <article id="10"><p class="chapter">10.考题抄错会做也白搭-模板方法模式</p></article>
        <article id="11"><p class="chapter">11.无熟人难办事?-迪米特法则</p></article>
        <article id="12"><p class="chapter">12.牛市股票还会亏钱?-外观模式</p></article>
        <article id="13"><p class="chapter">13.好菜每回味不同-建造者模式</p></article>
        <article id="14"><p class="chapter">14.老板回来,我不知道-观察者模式</p></article>
        <article id="15"><p class="chapter">15.就不能不换DB吗?-抽象工厂模式</p></article>
        <article id="16"><p class="chapter">16.无尽加班何时休-状态模式</p></article>
        <article id="17"><p class="chapter">17.在NBA我需要翻译-适配器模式</p></article>
        <article id="18"><p class="chapter">18.如果再回到从前-备忘录模式</p></article>
        <article id="19"><p class="chapter">19.分公司=-部分-组合模式</p></article>
        <article id="20"><p class="chapter">20.想走?可以!先买票-迭代器模式</p></article>
        <article id="21"><p class="chapter">21.有些类也需要计划生育-单例模式</p></article>
        <article id="22"><p class="chapter">22.手机软件何时统一-桥接模式</p></article>
        <article id="23"><p class="chapter">23.烤羊肉串引来的思考-命令模式</p></article>
        <article id="24"><p class="chapter">24.加薪非要老总批?-责任链模式</p></article>
        <article id="25"><p class="chapter">25.世界需要和平-中介者模式</p></article>
        <article id="26"><p class="chapter">26.项目多也别傻做-享元模式</p></article>
        <article id="27"><p class="chapter">27.其实你不懂老板的心-解释器模式</p></article>
        <article id="28"><p class="chapter">28.男人和女人-访问者模式</p></article>
        <article id="29"><p class="chapter">29.OOTV杯超级模式大赛-模式总结</p></article>
        <footer><a href="../../../../index.html">首页</a></footer>
        <script>
                // 读取存储的滚动位置并滚动到该位置  
            const scrollPositionKey = 'scrollPosition';  // 定义滚动位置变量
            const storedScrollPosition = localStorage.getItem(scrollPositionKey); // localStorage是存在用户设备上
            
            window.onload = function()  // 读取窗口的时候就回滚到上次位置
            {
                if (storedScrollPosition)  // 如果滚动位置存在 
                {  
                    window.scrollTo(0, parseInt(storedScrollPosition)); // 滚动到这个位置 
                } 
            } 
            
            // 监听滚动事件并存储位置  
            window.addEventListener('scroll', () => 
            {  
                const scrollPosition = window.scrollY || window.pageYOffset || document.body.scrollTop + (document.documentElement && document.documentElement.scrollTop || 0);  
                localStorage.setItem(scrollPositionKey, scrollPosition);  
            });
        </script>
    </body>
</html>
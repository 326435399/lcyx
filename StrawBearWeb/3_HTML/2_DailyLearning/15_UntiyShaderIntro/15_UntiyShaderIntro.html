<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="UTF-8">
        <meta name="StrawBear" content="width=device-width,initial-scale=1.0">
        <title>UnityShader入门与实践</title>
        <link rel="stylesheet" href="../../../1_CSS/basicStyle.css">
    </head>   
    <body>
        <aside>
            <ul>
                <li><a href="#1">1 数学基础</a>
                    <ul>
                        <li><a href="#1.1">1.1 向量</a></li>
                        <li><a href="#1.2">1.2 矩阵与空间</a></li>
                    </ul>
                </li>
                <li><a href="#2">2 渲染流水线</a>
                    <ul>
                        <li><a href="#2.1">2.1 教机器人画速写</a></li>
                        <li><a href="#2.2">2.2 GPU的"思维方式"</a></li>
                        <li><a href="#2.3">2.3 应用阶段</a></li>
                        <li><a href="#2.4">2.4 几何阶段</a></li>
                        <li><a href="#2.5">2.5 光栅化阶段</a></li>
                        <li><a href="#2.6">2.6 可编程渲染管线:Unity SRP</a></li>
                    </ul>
                </li>
                <li><a href="#3">3 Shader基础</a>
                    <ul>
                        <li><a href="#3.1">3.1 我的第一个Shader</a></li>
                        <li><a href="#3.2">3.2 Properties</a></li>
                        <li><a href="#3.3">3.3 SubShader</a></li>
                        <li><a href="#3.4">3.4 Pass</a></li>
                        <li><a href="#3.5">3.5 Shader内的结构体</a></li>
                        <li><a href="#3.6">3.6 顶点着色器</a></li>
                        <li><a href="#3.7">3.7 片元着色器</a></li>
                        <li><a href="#3.8">3.8 我该怎么写呢</a></li>
                    </ul>
                </li>
                <li><a href="#4">4 上个色吧:基础Shader入手</a>
                    <ul>
                        <li><a href="#4.1">4.1 纹理</a></li>
                        <li><a href="#4.2">4.2 不同空间的操作</a></li>
                        <li><a href="#4.3">4.3 控制覆盖的方式</a></li>
                        <li><a href="#4.4">4.4 完善材质面板:Properties</a></li>
                        <li><a href="#4.5">4.5 你能获得的其他信息</a></li>
                    </ul>
                </li>
                <li><a href="#5">5 计算与串联:需要思考的Shader</a>
                    <ul>
                        <li><a href="#5.1">5.1 边缘光效果</a></li>
                        <li><a href="#5.2">5.2 简单光照</a></li>
                        <li><a href="#5.3">5.3 法线贴图</a></li>
                        <li><a href="#5.4">5.4 类玻璃物体的渲染</a></li>
                    </ul>
                </li>
                <li><a href="#6">6 在模型上雕塑:Shader与几何</a></li>
                <li><a href="#7">7 中转站:RenderTexture</a></li>
                <li><a href="#8">8 非真实感渲染</a></li>
                <li><a href="#9">9 真的入门了吗</a></li>
            </ul>
        </aside>
        <nav>
            
            <a href="#20240505"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240505-小熊的隐身能力:<br>
            小熊被吸入了游戏空间当中,游戏是一个RPG游戏,主角小熊需要收集沿途掉落的各种能力球来升级打败BOSS扭曲彩虹龙<br>
            第一个能力球是隐身球,小熊获得之后就会隐去身形,但是因为不知名的原因,小熊人隐身了,但是影子依然还在,导致不断被怪物追杀.<br>
            后来小熊找到了问题所在,原来它在计算<strong>ShadowCaster</strong>的时候没有裁切,所以阴影部分依然还在,修改之后小熊就成功逃过了追杀获得了第一个能力-隐身<br>
            <a href="#20240506"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240506-多光源照射能力:<br>
            小熊的武器是一把灯光枪,可以发出三种类型的光线,<strong>Directional平行光,Point点光,Spot聚光灯</strong>,大部分的怪物都是因为光照不足而狂暴的植物,需要分别
            吸收着三种类型的光到一定程度就会恢复正常,然后小熊就可以获得它们守护的能力球.现在碰到的第一个问题是这把枪坏了,不能同时开启三种光照,经过解密
            最终发现是需要给枪增加一个ForwardAdd芯片模块,调整参数到One,One这样光照就能共存了,但是依然存在一个问题,切换是随机的,没办法准确调整到三种指定的
            光照,后来发现是输入的能量结构体不对,需要是符合规格的标准命名的能量输入才行,例如vertex,uv,normal等等.<br>
            <a href="#20240507"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240507-补充光能-球谐:<br>
            小熊的灯光枪的能量是通过枪上的球形宝珠吸收周围光照来充能的,这个宝珠也需要不断地获取能力球才能提高吸收效率(对环境的捕捉越细致就会有更多的光照变化,吸收率就越高)
            采用的是<strong>球谐函数</strong>,初始阶段只有0阶,充能一次只能使用1天,小熊通过前面的两次试炼获得了两次升级,现在可以充能一次使用一个星期了,球体通过显示的星星数量
            来表示当前阶段,3阶是5个数,会用5个数记录下不同方向的环境光照,最后当做能量释放出去给怪物增加光照<br>
            <a href="#20240510"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240510-提高充能效率的手段-光照贴图:<br>
            补充光能的升级方式是通过提高<strong>烘焙</strong>光照效率来实现的,每次击败怪物升级之后,就会提供烘焙当中使用的<strong>路径追踪</strong>算法的计算速率,
            在一定的等级还能够直接更换更加强大的算法,例如在6级可以学到第一个大招,为路径追踪算法提供<strong>Meta</strong>通道,提高渲染效果.<br>
        </nav>
        <header><h1>UnityShader入门与实践</h1></header>
        <article id="1"><h2>1 数学基础</h2>
            <section id="1.1">1.1 向量</section>
            <p></p>
            <section id="1.2">1.2 矩阵与空间</section>
            <p></p>
        </article>
        <article id="2"><h2>2 渲染流水线</h2>
            <section id="2.1">2.1 教机器人画速写</section>
            <p></p>
            <section id="2.2">2.2 GPU的"思维方式"</section>
            <p></p>
            <section id="2.3">2.3 应用阶段</section>
            <p></p>
            <section id="2.4">2.4 几何阶段</section>
            <p></p>
            <section id="2.5">2.5 光栅化阶段</section>
            <p></p>
            <section id="2.6">2.6 可编程渲染管线:Unity SRP</section>
            <p></p>
        </article>
        <article id="3"><h2>3 Shader基础</h2>
            <section id="3.1">3.1 我的第一个Shader</section>
            <p></p>
            <section id="3.2">3.2 Properties</section>
            <p></p>
            <section id="3.3">3.3 SubShader</section>
            <p></p>
            <section id="3.4">3.4 Pass</section>
            <p></p>
            <section id="3.5">3.5 Shader内的结构体</section>
            <p></p>
            <section id="3.6">3.6 顶点着色器</section>
            <p></p>
            <section id="3.7">3.7 片元着色器</section>
            <p></p>
            <section id="3.8">3.8 我该怎么写呢</section>
            <p></p>           
        </article>
        <article id="4"><h2>4 上个色吧:基础Shader入手</h2>
            <section id="4.1">4.1 纹理</section>
            <p></p>
            <section id="4.2">4.2 不同空间的操作</section>
            <p></p>
            <section id="4.3">4.3 控制覆盖的方式</section>
            <p></p>
            <section id="4.4">4.4 完善材质面板:Properties</section>
            <p></p>
            <section id="4.5">4.5 你能获得的其他信息</section>
            <p></p>
        </article>
        <article id="5"><h2>5 计算与串联:需要思考的Shader</h2>
            <section id="5.1">5.1 边缘光效果</section>
            <p></p>
            <section id="5.2">5.2 简单光照</section>
            <p>
                <p>
                    <p class="timeStamp" id="20240505">20240505开始</p>
                    <strong>5.2.4 阴影</strong>
                    <figure>
                        <img src="Resources/img/5-2-4-1 裁切阴影代码.png" alt="裁切阴影代码">
                        <p>
                            为了实现对于透明物体的正确阴影,需要在ShodwCaster通道当中对阴影执行同样的裁切逻辑.<br>
                            SHADOW_COORDS,TRANSFER_SHADOW,SHADOW_ATTENUATION是Unity提供的帮助执行阴影计算的宏,是一个系列的.<br>
                        </p>
                    </figure>
                    <figure>
                        <img src="Resources/img/5-2-4-2 代码结果.png" alt="代码结果">
                        <p>
                            实现了对于透明物体的阴影裁切效果.
                        </p>
                    </figure>
                    <p class="timeStamp" id="20240506">20240506开始</p>

                    <strong>5.2.5 多光源渲染</strong><br>
                    <figure>
                        <img src="Resources/img/5-2-5-1-发现问题.png" alt="发现问题">
                        <p>
                            发现问题:新增灯光但是灯光不会影响物体的颜色<br>
                        </p>
                    </figure>
                    Unity将场景中的灯光区分为主光和其他光,主光在ForwardBase的通道里面处理了,而其他光则在ForwardAdd通道,每多一盏灯都要重复调用这个通道.<br>
                    <figure>
                        <img src="Resources/img/5-2-5-2-新增其他灯通道.png" alt="新增其他灯通道">
                        <p>
                            新增了ForwardAdd通道<br>                            
                        </p>
                    </figure>
                    <figure>
                        <img src="Resources/img/5-2-5-3-新的问题.png" alt="新的问题">
                        <p>
                            1.不能多个灯光同时受到影响.<br>
                            2.点光源对物体的影响是固定的,没有衰减.<br>
                            3.点光源产生的阴影不能正确的在材质上产生效果.<br>
                        </p>
                    </figure>

                    1.多个灯光问题
                    <figure>
                        <img src="Resources/img/5-2-5-4-灯光共存.png" alt="灯光共存">
                        <p>
                            解决第一个问题的方案很简单,之所以产生这个不混合的原因是混合方式,因为其他光源采用的混合模式会替换其他光源,所以不行.<br>
                            我们使用Blend One One把光照给叠加起来,这样就可以实现多个灯光同时存在了<br>
                        </p>
                    </figure>

                    2.灯光显示问题
                    <figure>
                        <img src="Resources/img/5-2-5-5-其余灯光问题.png" alt="其余灯光问题">
                        <p>
                            现在其余的灯光存在问题,原因就在于我们只计算了平行光这一种类型的灯光,所以其他灯光类型的效果不正确,显然我们应该对平行光,点光
                            ,聚光灯,片灯写不同的支持.<br>
                        </p>
                    </figure>

                    <figure>
                        <img src="Resources/img/5-2-5-6-点光源衰减.png" alt="点光源衰减">
                        <p>
                            点光源抽象出来的特性是从中心点往外按照平方反比的关系进行衰减.<br>
                        </p>
                    </figure>

                    <figure>
                        <img src="Resources/img/5-2-5-7-碰到的一些问题.png" alt="碰到的一些问题">
                        <p>
                            碰到了挺多问题,第一个就是Unity提供的宏很多要求固定的结构体名字,所以很多其他名字会带来问题.<br>
                            第二个问题是如果使用#ifdef来判断使用哪个灯光失败了,原因暂时不明,但是使用宏又没有问题<br>
                        </p>
                    </figure>

                    <p class="timeStamp" id="20240507">20240507开始</p>

                    <p>
                        <div class="paragraph">5.2.6 球谐照明</div>
                        <figure>
                            <img src="Resources/img/5-2-6-01-光照小球.png" alt="光照小球">
                            <p>
                                情境:在晴天的室内放置一个小球,顶部收到灯光照射,前方受到窗户阳光的照射,右侧来自墙壁的反光,底部收到来自地板的反光,这些光都有不同的强度和颜色,他们共同构成了小球的照明.<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-6-02-简化考虑.png" alt="简化考虑">
                            <p>
                                思考:如果我们能够把一个点四周的光照都存储起来,这样可以通过输入一个方向来查这个方向的环境光照值.<br>
                                简化:光强可以认为是光色*强度,光色是RGB三维向量值,强度是一个一维标量值,他们乘起来结果自然还是一个三维向量.<br>
                                思考:这意味着我们可以用一个三维向量来表示一个点的环境光照.<br>
                                简化:我们先只考虑一个通道R通道,也先不考虑三维,先考虑二维坐标系,考虑R与角度θ的关系<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-6-03-傅里叶拟合.png" alt="傅里叶拟合">
                            <p>
                                思考:我们现在需要一个函数来尽可能的还原这个曲线(保留准确的光照信息),很容易想到的两个方法是泰勒展开和傅里叶变换,泰勒展开转换成N项多项式,傅里叶变换则是用多个正弦函数的叠加来还原.傅里叶拟合之后用函数R≈0.5sin(0.2x)+0.5sin(0.8x)+sin(0.1x)来近似表征<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-6-04-极坐标基函数.png" alt="极坐标基函数">
                            <p>
                                思考:在函数空间当中,可以将连续函数表示为若干个基函数的线性组合.为了方便组合自然需要选择正交化的基函数-函数空间正交基.<br>
                                思考:现在将二维直角平面坐标系升级到二维极坐标系,想象描述的是一个平面上光照情况的函数,为了表示复杂的结果,我们需要更高阶的基函数来表示<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-6-05-代码表示.png" alt="代码表示">
                            <p>
                                思考:极坐标空间下的光照我们用三阶就近似的存储下来了,总共需要存储5个值,也就是1个5维度的向量就可以存储下来了.只需要输入想要查询的点的方向矢量u,然后代入这个方程,就可以求出来光照值了.<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-6-06-球谐函数基函数.png" alt="球谐函数基函数">
                            <p>
                                思考:接下来把二维的基坐标升级到三维基坐标空间,这自然需要更多的基函数.球谐函数的基函数通用表达式,其中i为虚数符号,Plm是伴随Legendre多项式 <br>                               
                                <a href="https://en.wikipedia.org/wiki/Spherical_harmonics">球谐函数-维基百科</a>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-6-07-球谐函数.png" alt="球谐函数">
                            <p>
                                思考:根据不同的l与m可以得到对应的球谐函数,然后使用球谐函数来存储近似的环境光照.<br>
                                简化:Unity默认使用三阶球谐函数,通过ShaderSH9函数可以获取球谐光照的信息,需要输入点的法线信息(就能获取这个方向的球谐光照信息了)ShaderSH9(float4法线信息)<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">5.2.7 障眼法</p>
                    <p>
                        概念:除了直接光照外,一种更为取巧的光照计算方法:烘焙(Bake)-采用离线渲染的方式计算出当前场景的光照情况,并将结果保持你在一张光照贴图上.<br>
                        简化:原本的光影计算被压缩到了光照贴图,变成了采样-输出,用存储的空间替换了计算消耗.<br>
                        原理:Unity使用路径追踪(Path Tracing)来计算光照,光源发射射线,碰到物体表面就是反射或折射或吸收,反射到摄像机的部分就表示能接受到这个光照,就计算光照值,通过大量采样来求真实结果;优点是真实且采样快速,缺点是计算的结果和摄像机无关,所以依赖于观察方向的效果(如高光)是无效的.另外一个缺点是贴图是固定的,所以物体移动后结果就不正确了<br>

                        <figure>
                            <img src="Resources/img/5-2-7-01-半影区域.png" alt="半影区域">
                            <p>
                                现象:在现实中光源是有体积的,所以我们计算的阴影应该是有平滑的过渡范围,而不是生硬的边缘<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-7-02-软硬阴影.png" alt="软硬阴影">
                            <p>
                                简化:Unity当中渲染实际上很少计算光源真正的体积,而是采用了烘焙阴影角度(Baked Sahdow Angle)来近似阴影边缘过渡面积,左图是没有开启,右图是开启的<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-7-03-几种烘焙模式.png" alt="几种烘焙模式">
                            <p>
                                通常都是shadowmask<br>
                            </p>
                        </figure>

                        获取光照贴图
                        <figure>
                            <img src="Resources/img/5-2-7-04-获取光照UV.png" alt="获取光照UV">
                            <p>
                                1.在应用程序结构体获得光照UV,LIGHTMAP_ON是官方提供的宏,会获取是否使用光照贴图的信息<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-7-05-顶点着色器处理光照UV.png" alt="顶点着色器处理光照UV">
                            <p>
                                2.顶点->片段着色器结构体当中计算经过Tilling和Offset后的UV值传递
                                <figure>
                                    <img src="Resources/img/5-2-7-06-计算TO之后的UV.png" alt="计算TO之后的UV">
                                    <p>
                                        2.1 在顶点着色器当中计算<br>
                                    </p>
                                </figure>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-7-07-使用光照贴图.png" alt="使用光照贴图">
                            <p>
                                3.在片段着色器当中使用光照贴图<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-7-08-提供给烘焙使用.png" alt="提供给烘焙使用">
                            <p>
                                4.提供供烘焙过程使用的代码,还有很多细节不清楚<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/5-2-7-09-结果.png" alt="结果">
                            <p>
                                5.结果就是可以支持烘焙了<br>
                            </p>
                        </figure>
                    </p>
                </p>
            </p>
            <section id="5.3">5.3 法线贴图</section>
            <p></p>
            <section id="5.4">5.4 类玻璃物体的渲染</section>
            <p></p>
        </article>
        <article id="6"><h2>6 在模型上雕塑:Shader与几何</h2>
            <section id="6.1">1.1 安装基础软件</section>
            <p></p>
        </article>
        <article id="7"><h2>7 中转站:RenderTexture</h2>
            <section id="7.1">1.1 安装基础软件</section>
            <p></p>
        </article>
        <article id="8"><h2>8 非真实感渲染</h2>
            <section id="8.1">1.1 安装基础软件</section>
            <p></p>
        </article>
        <article id="9"><h2>9 真的入门了吗</h2>
            <section id="9.1">1.1 安装基础软件</section>
            <p></p>
        </article>
        <footer><a href="../../../../index.html">首页</a></footer>
        <script>
                // 读取存储的滚动位置并滚动到该位置  
            const scrollPositionKey = 'scrollPosition';  // 定义滚动位置变量
            const storedScrollPosition = localStorage.getItem(scrollPositionKey); // localStorage是存在用户设备上
            
            window.onload = function()  // 读取窗口的时候就回滚到上次位置
            {
                if (storedScrollPosition)  // 如果滚动位置存在 
                {  
                    window.scrollTo(0, parseInt(storedScrollPosition)); // 滚动到这个位置 
                } 
            } 
            
            // 监听滚动事件并存储位置  
            window.addEventListener('scroll', () => 
            {  
                const scrollPosition = window.scrollY || window.pageYOffset || document.body.scrollTop + (document.documentElement && document.documentElement.scrollTop || 0);  
                localStorage.setItem(scrollPositionKey, scrollPosition);  
            });
        </script>
    </body>
</html>
<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="UTF-8">
        <meta name="StrawBear" content="width=device-width,initial-scale=1.0">
        <title>DesignPatternGOF4</title>
        <link rel="stylesheet" href="../../../1_CSS/basicStyle.css">
    </head>   
    <body>
        <aside>
            <ul>
                <li><a href="#1">1 引言</a>
                    <ul>
                        <li><a href="#1.1">1.1 什么是设计模式</a></li>
                        <li><a href="#1.2">1.2 Smalltalk MVC中的设计模式</a></li>
                        <li><a href="#1.3">1.3 描述设计模式</a></li>
                        <li><a href="#1.4">1.4 设计模式的编目</a></li>
                        <li><a href="#1.5">1.5 组织编目</a></li>
                        <li><a href="#1.6">1.6 设计模式怎样解决设计问题</a></li>
                        <li><a href="#1.7">1.7 怎样选择设计模式</a></li>
                        <li><a href="#1.8">1.8 怎样使用设计模式</a></li>
                    </ul>
                </li>
                <li><a href="#2">2 实例研究:设计一个文档编辑器</a></li>
                <li><a href="#3">3 创建型模式</a></li>
                <li><a href="#4">4 结构型模式</a></li>
                <li><a href="#5">5 行为型模式</a></li>
                <li><a href="#6">6 结论</a></li>
            </ul>
        </aside>
        <nav>
            <a href="#20240514"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240514:抽象世界-设计模式世界<br>
            设计模式的世界是老师的世界,老师需要用抽象的语言来描述某些场景的解决方案<br>
            <a href="#20240515"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240515:Smalltalk的MVC<br>
            <strong>Smalltalk-80</strong>机器人采用了全新的<strong>MVC</strong>模型视口控制系统,模型M控制机器人的功能,视口V控制机器人窗口显示,控制器C控制具体功能的执行<br>

        </nav>
        <header><p class="header">DesignPatternGOF4</p><figure><img src="设计模式.jpg" alt="书籍封面"></figure></header>
        <article id="1"><p class="chapter">1.引言</p>
            <p class="timeStamp" id="20240514">20240514学习</p>
            <section id="1.1"><p class="section">1.1 什么是设计模式</p>
                <div>
                    目标:找到相关的对象,以适当的粒度将它们归类,再定义类的接口和继承层次,建立对象之间的基本关系,应该对手头的问题有针对性,对将来的问题和需求有足够的通用性.<br>
                    定义:设计模式即时把面向对象软件的设计经验(解决方案)按照一定格式记录下来.<br>
                    <br>
                    一个模式包含四个基本要素<br>
                    1.模式名(pattern name):一个助记名,用一两个次来描述模式的问题.解决方案和效果.<br>
                    允许我们在更高的抽象层次来思考,便于和其他人交流设计思想.<br>
                    <br>
                    2.问题(problem):描述了应该在何时使用模式.<br>
                    解释了问题的由来,也可能包含一定的问题前置条件<br>
                    <br>
                    3.解决方案(solution):描述了设计的组成成分.它们之间的相互关系以及格子的职责和协助方式.<br>
                    不描述一个具体的设计或实现,而是抽象层次的描述用什么方式解决<br>
                    <br>
                    4.效果(consequence):描述了模式应用功能的效果及使用模式应权衡的问题.<br>
                    大多关注时间,空间,性能,扩展性.<br>
                    <br>
                    本书的设计模式是:对用来在特定场景下解决一般设计问题的类和相互通信的对象的描述.<br>
                </div>
            </section>

            <p class="timeStamp" id="20240515">20240515学习</p>
            <section id="1.2"><p class="section">1.2 Smalltalk MVC中的设计模式</p>
                <div>
                    <p class="paragraph">Smalltalk-80简介</p>
                    <p>
                        <figure>
                            <img src="Resources/img/01-01-MVC.png" alt="MVC">
                            <p>
                                Smalltalk-80是一门设计语言,带有开发环境,集成了MVC模式.<br>
                                类的模型/视图/控制器(Model/View/Controller)被用来构建用户界面.<br>
                                模型是应用对象,视图是它在屏幕上的表示,控制器定义用户界面对用户输入的响应方式.<br>
                            </p>
                        </figure>
                    </p>

                    <p class="paragraph">MVC中用到的模式</p>
                    <p>
                        <strong>Observer观察者模式:</strong><br>
                        MVC通过订购/通知协议来分离视图和模型.视图必须保证它的显示正确地反映了模型的状态.一旦模型变化,会通知视图更新自己.<br>
                        归纳:这种将对象分离,使得一个对象的改变能够影响另一些对象,而这个对象不需要知道那些被影响对象的细节,知道是谁就可以了.这个设计模式叫做Observer观察者模式<br>
                        <br>
                        <strong>Composite组合模式:</strong><br>
                        MVC的另一个特征是视图可以嵌套.<br>
                        用View类的子类CompositeView类来支持嵌套视图,CompositeView类对象行为类似View类的行为,这当中提取出的一般性问题.<br>
                        归纳:将一组对象划为一组,并将该组对象当作一个对象来使用,这个设计模式叫做Composite组合模式<br>
                        <br>
                        <strong>Strategy策略模式</strong><br>
                        MVC允许在不改变视图外观的情况下改变视图对用户输入的响应方式,响应机制通过Controller策略接口封装,只需要更换不同的Controller实例类就可以实现不同的响应方式.<br>
                        归纳:这种一个策略是一个表述算法的对象的设计模式叫做Strategy策略模式<br>

                        <strong>其他模式</strong><br>
                        MVC视图默认控制器创建类使用了FactoryMethod工厂方法,增加视图滚动功能的Decorator装饰者模式.等等<br>
                    </p>                    
                </div>
            </section>
            <section id="1.3"><p class="section">1.3 描述设计模式</p>
                <p class="paragraph">编目的学习顺序</p>
                <p>
                    1.已知应用:现实中使用它的例子<br>
                    2.动机:解决什么问题?<br>
                    3.意图:做到什么?<br>
                    4.适用性:什么时候可以用<br>
                    5.结构:解决问题的结构描述UML图<br>
                    6.参与者:模式中的类或对象以及各自的职责<br>
                    7.协作:参与者之间怎么协作<br>
                    8.效果:结果是怎样的,优缺点<br>
                    9.实现:技术要点提示<br>
                    10.代码示例:实例说明<br>
                    11.相关模式:和其他模式之间的关系<br>
                    12.模式名和分类:模式名简洁的描述了模式的本质,分类则帮助形成不同用途的划分.<br>
                    13.别名:模式的其他名称.<br>
                </p>
            </section>
            <section id="1.4"><p class="section">1.4 设计模式的编目</p></section>
            <section id="1.5"><p class="section">1.5 组织编目</p></section>
            <section id="1.6"><p class="section">1.6 设计模式怎样解决设计问题</p></section>
            <section id="1.7"><p class="section">1.7 怎样选择设计模式</p></section>
            <section id="1.8"><p class="section">1.8 怎样使用设计模式</p></section>
        </article>
        <article id="2"><p class="chapter">2 实例研究:设计一个文档编辑器</p></article>
        <article id="3"><p class="chapter">3 创建型模式</p></article>
        <article id="4"><p class="chapter">4 结构型模式</p></article>
        <article id="5"><p class="chapter">5 行为型模式</p></article>
        <article id="6"><p class="chapter">6 结论</p></article>
        <footer><a href="../../../../index.html">首页</a></footer>
        <script>
                // 读取存储的滚动位置并滚动到该位置  
            const scrollPositionKey = 'scrollPosition';  // 定义滚动位置变量
            const storedScrollPosition = localStorage.getItem(scrollPositionKey); // localStorage是存在用户设备上
            
            window.onload = function()  // 读取窗口的时候就回滚到上次位置
            {
                if (storedScrollPosition)  // 如果滚动位置存在 
                {  
                    window.scrollTo(0, parseInt(storedScrollPosition)); // 滚动到这个位置 
                } 
            } 
            
            // 监听滚动事件并存储位置  
            window.addEventListener('scroll', () => 
            {  
                const scrollPosition = window.scrollY || window.pageYOffset || document.body.scrollTop + (document.documentElement && document.documentElement.scrollTop || 0);  
                localStorage.setItem(scrollPositionKey, scrollPosition);  
            });
        </script>
    </body>
</html>
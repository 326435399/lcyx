<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="UTF-8">
        <meta name="StrawBear" content="width=device-width,initial-scale=1.0">
        <title>设计模式之禅</title>
        <link rel="stylesheet" href="../../../1_CSS/basicStyle.css">
    </head>   
    <body>
        <aside>
            <ul>
                <li><a href="#1">1 单一职责原则</a>
                    <ul>
                        <li><a href="#1.1">1.1 我是"牛"类,我可以担任多职吗</a></li>
                        <li><a href="#1.2">1.2 绝杀技,打破你的传统思维</a></li>
                        <li><a href="#1.3">1.3 我单纯,所以我快乐</a></li>
                    </ul>
                </li>
                <li><a href="#2">2 里氏替换原则</a>
                    <ul>
                        <li><a href="#2.1">2.1 爱恨纠葛的父子关系</a></li>
                        <li><a href="#2.2">2.2 纠纷不断,规则压制</a></li>
                    </ul>
                </li>
                <li><a href="#3">3 依赖倒置原则</a>
                    <ul>
                        <li><a href="#3.1">3.1 依赖倒置原则的定义</a></li>
                        <li><a href="#3.2">3.2 言而无信,你太需要契约</a></li>
                        <li><a href="#3.3">3.3 依赖的三种写法</a></li>
                    </ul>
                </li>
                <li><a href="#4">4 接口隔离原则</a>
                    <ul>
                        <li><a href="#4.1">4.1 接口隔离原则的定义</a></li>
                        <li><a href="#4.2">4.2 美女何其多,观点个不同</a></li>
                        <li><a href="#4.3">4.3 保证接口的纯洁性</a></li>
                    </ul>
                </li>
                <li><a href="#5">5 迪米特法则</a>
                    <ul>
                        <li><a href="#5.1">5.1 迪米特法则的定义</a></li>
                        <li><a href="#5.2">5.2 我的知识你知道得越少越好</a></li>
                    </ul>
                </li>
                <li><a href="#6">6 开闭原则</a>
                    <ul>
                        <li><a href="#6.1">6.1 开闭原则的定义</a></li>
                        <li><a href="#6.2">6.2 开闭原则的庐山真面目</a></li>
                        <li><a href="#6.3">6.3 为什么要采用开闭原则</a></li>
                        <li><a href="#6.4">6.4 如恶化使用开闭原则</a></li>
                    </ul>
                </li>
                <li><a href="#7">7 单例模式</a>
                    <ul>
                        <li><a href="#7.1">7.1 我是皇帝我独苗</a></li>
                        <li><a href="#7.2">7.2 单例模式的定义</a></li>
                        <li><a href="#7.3">7.3 单例模式的应用</a></li>
                        <li><a href="#7.4">7.4 单利模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#8">8 工厂方法模式</a>
                    <ul>
                        <li><a href="#8.1">8.1 女娲造人的故事</a></li>
                        <li><a href="#8.2">8.2 工厂方法模式的定义</a></li>
                        <li><a href="#8.3">8.3 工厂方法模式的应用</a></li>
                        <li><a href="#8.4">8.4 工厂方法模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#9">9 抽象工厂模式</a>
                    <ul>
                        <li><a href="#9.1">9.1 女娲的失误</a></li>
                        <li><a href="#9.2">9.2 抽象工厂模式的定义</a></li>
                        <li><a href="#9.3">9.3 抽象工厂模式的应用</a></li>
                    </ul>
                </li>
                <li><a href="#10">10 模板方法模式</a>
                    <ul>
                        <li><a href="#10.1">10.1 辉煌工程-制造悍马</a></li>
                        <li><a href="#10.2">10.2 模板方法模式的定义</a></li>
                        <li><a href="#10.3">10.3 模板方法模式的应用</a></li>
                        <li><a href="#10.4">10.4 模板方法模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#11">11 建造者模式</a>
                    <ul>
                        <li><a href="#11.1">11.1 变化是永恒的</a></li>
                        <li><a href="#11.2">11.2 建造者模式的定义</a></li>
                        <li><a href="#11.3">11.3 建造者模式的应用</a></li>
                        <li><a href="#11.4">11.4 建造者模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#12">12 代理模式</a>
                    <ul>
                        <li><a href="#12.1">12.1 我是游戏至尊</a></li>
                        <li><a href="#12.2">12.2 代理模式的定义</a></li>
                        <li><a href="#12.3">12.3 代理模式的应用</a></li>
                        <li><a href="#12.4">12.4 代理模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#13">13 原型模式</a>
                    <ul>
                        <li><a href="#13.1">13.1 个性化电子账单</a></li>
                        <li><a href="#13.2">13.2 原型模式的定义</a></li>
                        <li><a href="#13.3">13.3 原型模式的应用</a></li>
                        <li><a href="#13.4">13.4 原型模式的注意事项</a></li>
                    </ul>
                </li>
                <li><a href="#14">14 中介者模式</a>
                    <ul>
                        <li><a href="#14.1">14.1 进销存管理是这个样子的吗</a></li>
                        <li><a href="#14.2">14.2 中介者模式的定义</a></li>
                        <li><a href="#14.3">14.3 中介者模式的应用</a></li>
                        <li><a href="#14.4">14.4 中介者模式的实际应用</a></li>
                    </ul>
                </li>
                <li><a href="#15">15 命令模式</a>
                    <ul>
                        <li><a href="#15.1">15.1 项目经理也难当</a></li>
                        <li><a href="#15.2">15.2 命令模式的定义</a></li>
                        <li><a href="#15.3">15.3 命令模式的应用</a></li>
                        <li><a href="#15.4">15.4 命令模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#16">16 责任链模式</a>
                    <ul>
                        <li><a href="#16.1">16.1 古代妇女的枷锁-"三从四德"</a></li>
                        <li><a href="#16.2">16.2 责任链模式的定义</a></li>
                        <li><a href="#16.3">16.3 责任链模式的应用</a></li>
                    </ul>
                </li>
                <li><a href="#17">17 装饰模式</a>
                    <ul>
                        <li><a href="#17.1">17.1 罪恶的成绩单</a></li>
                        <li><a href="#17.2">17.2 装饰模式的定义</a></li>
                        <li><a href="#17.3">17.3 装饰模式应用</a></li>
                    </ul>
                </li>
                <li><a href="#18">18 策略模式</a>
                    <ul>
                        <li><a href="#18.1">18.1 刘备江东娶妻,赵云他容易吗</a></li>
                        <li><a href="#18.2">18.2 策略模式的定义</a></li>
                        <li><a href="#18.3">18.3 策略模式的应用</a></li>
                        <li><a href="#18.4">18.4 策略模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#19">19 适配器模式</a>
                    <ul>
                        <li><a href="#19.1">19.1 业务发展-上帝才能控制</a></li>
                        <li><a href="#19.2">19.2 适配器模式的定义</a></li>
                        <li><a href="#19.3">19.3 适配器模式的应用</a></li>
                        <li><a href="#19.4">19.4 适配器模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#20">20 迭代器模式</a>
                    <ul>
                        <li><a href="#20.1">20.1 整理项目信息-苦差事</a></li>
                        <li><a href="#20.2">20.2 迭代器模式的定义</a></li>
                        <li><a href="#20.3">20.3 迭代器模式的应用</a></li>
                    </ul>
                </li>
                <li><a href="#21">21 组合模式</a>
                    <ul>
                        <li><a href="#21.1">21.1 公司的人事架构是这样的吗</a></li>
                        <li><a href="#21.2">21.2 组合模式的定义</a></li>
                        <li><a href="#21.3">21.3 组合模式的应用</a></li>
                        <li><a href="#21.4">21.4 组合模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#22">22 观察者模式</a>
                    <ul>
                        <li><a href="#22.1">22.1 韩非子身边的卧底是谁派来的</a></li>
                        <li><a href="#22.2">22.2 观察者模式的定义</a></li>
                        <li><a href="#22.3">22.3 观察者模式的应用</a></li>
                        <li><a href="#22.4">22.4 观察者模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#23">23 门面模式</a>
                    <ul>
                        <li><a href="#23.1">23.1 我要投递信件</a></li>
                        <li><a href="#23.2">23.2 门面模式的定义</a></li>
                        <li><a href="#23.3">23.3 门面模式的应用</a></li>
                        <li><a href="#23.4">23.4 门面模式的注意事项</a></li>
                    </ul>
                </li>
                <li><a href="#24">24 备忘录模式</a>
                    <ul>
                        <li><a href="#24.1">24.1 如此追女孩子,你还不乐</a></li>
                        <li><a href="#24.2">24.2 备忘录模式的定义</a></li>
                        <li><a href="#24.3">24.3 备忘录模式的应用</a></li>
                        <li><a href="#24.4">24.4 备忘录模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#25">25 访问者模式</a>
                    <ul>
                        <li><a href="#25.1">25.1 员工的隐私何在</a></li>
                        <li><a href="#25.2">25.2 访问者模式的定义</a></li>
                        <li><a href="#25.3">25.3 访问者模式的应用</a></li>
                        <li><a href="#25.4">25.4 访问者模式的扩展</a></li>
                    </ul>
                </li>
                <li><a href="#26">26 状态模式</a>
                    <ul>
                        <li><a href="#26.1">26.1 城市的纵向发展功臣-电梯</a></li>
                        <li><a href="#26.2">26.2 状态模式的定义</a></li>
                        <li><a href="#26.3">26.3 状态模式的应用</a></li>
                    </ul>
                </li>
                <li><a href="#27">27 解释器模式</a>
                    <ul>
                        <li><a href="#27.1">27.1 四则运算你会吗</a></li>
                        <li><a href="#27.2">27.2 解释器模式的定义</a></li>
                        <li><a href="#27.3">27.3 解释器模式的应用</a></li>
                    </ul>
                </li>
                <li><a href="#28">28 享元模式</a>
                    <ul>
                        <li><a href="#28.1">28.1 内存溢出,司空见惯</a></li>
                        <li><a href="#28.2">28.2 享元模式的定义</a></li>
                        <li><a href="#28.3">28.3 享元模式的应用</a></li>
                        <li><a href="#28.4">28.4 享元模式的应用</a></li>
                    </ul>
                </li>
                <li><a href="#29">29 桥梁模式</a>
                    <ul>
                        <li><a href="#29.1">29.1 我有一个梦想</a></li>
                        <li><a href="#29.2">29.2 桥梁模式的定义</a></li>
                        <li><a href="#29.3">29.3 桥梁模式的应用</a></li>
                    </ul>
                </li>
                <li><a href="#30">30 创建类模式大PK</a>
                    <ul>
                        <li><a href="#30.1">30.1 工厂方法模式VS建造者模式</a></li>
                        <li><a href="#30.2">30.2 抽象工厂模式VS建造者模式</a></li>
                    </ul>
                </li>
                <li><a href="#31">31 结构类模式大PK</a>
                    <ul>
                        <li><a href="#31.1">31.1 代理模式VS装饰模式</a></li>
                        <li><a href="#31.2">31.2 装饰模式VS适配器模式</a></li>
                    </ul>
                </li>
                <li><a href="#32">32 行为类模式大PK</a>
                    <ul>
                        <li><a href="#32.0">32.0 总览</a></li>
                        <li><a href="#32.1">32.1 命令模式VS策略模式</a></li>
                        <li><a href="#32.2">32.2 策略模式VS状态模式</a></li>
                        <li><a href="#32.3">32.3 观察者模式VS责任链模式</a></li>
                    </ul>
                </li>
                <li><a href="#33">33 跨战区PK</a>
                    <ul>
                        <li><a href="#33.1">32.1 策略模式VS桥梁模式</a></li>
                        <li><a href="#33.2">32.2 门面模式VS中介者模式</a></li>
                        <li><a href="#33.3">32.3 包装模式群PK</a></li>
                    </ul>
                </li>
                <li><a href="#34">34 命令模式+责任链模式</a></li>
                <li><a href="#35">35 工厂方法模式+策略模式</a></li>
                <li><a href="#36">36 观察者模式+中介者模式</a></li>
                <li><a href="#37">37 MVC框架</a></li>
                <li><a href="#38">38 新模式</a></li>
            </ul>
        </aside>
        <nav>
            <a href="../../4_MonthLearning/3-DesignMode/20240429_UML.html">UML语言学习</a>           
            <a href="#20240505"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240505:小熊的炼丹炉<br>
            小熊有一个青铜炼丹炉用来生产不同的丹药产品,炼丹炉虽然锈迹斑斑,但是上面有LED显示屏,可以选择五种不同的炼丹模式:<br>
            分别是单例模式,原型模式,建造者模式,工厂方法模式,抽象工厂模式.五种不同的模式有不同的作用.<br>
            <strong>单例模式</strong>会消耗所有的药材,炼制唯一的一颗丹药,因此这颗丹药往往价值不菲.例如十全补血丸<br>
            <strong>原型模式</strong>则是根据上一次炼制的原型,重复炼制批量产生相同的丹药,有利于在找到合适的药方之后批量生产.<br>
            <strong>工厂方法模式</strong>可以设置想要生产的丹药类型,例如设置补血丸,则可以根据投入的药物不同生产小补血丸和大补血丸.<br>
            <strong>抽象工厂模式</strong>不但可以设置丹药类型,还可以控制火候,这样哪怕是相同的有药物也可以通过这两个维度的控制产生不同的产品.例如稳定火候的小补血丸肯定是比不稳定火候的小补血丸要价值更高的<br>
            <strong>建造者模式</strong>又称为大师模式,往往是针对非常珍贵的药材,可以控制炼药过程的火候,熔炼方式等等,拥有对炼制过程的绝对控制,不同的过程会带来不同的产品,属于定制化产品.大师炼制的补血丸自然是比普通药剂师要练得昂贵,因为过程的控制不同<br>
            <br>    
            <a href="#20240506"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240506:炼丹炉的拼装<br> 
            这个青铜炼丹炉是小熊自己组装的,青铜炉的盖比较小不能盖好,所以我们需要使用<strong>适配器</strong>(衔接小盖的基础上扩大下盘)才能盖好.<br>
            炉腿整体采用的是<strong>桥接</strong>的方式,镶嵌的炉体底座上形成底,每个炉腿和镶嵌口都通过定位器作为<strong>代理</strong>衔接在一起<br>
            炉体则是青铜一体铸造,为了<strong>外观</strong>好看的功能,<strong>装饰</strong>上了使用<strong>组合</strong>递归形成的青铜树状结构作为花纹<br>
            这个青铜炼丹炉也会添加到共享池当中,每个需要的人都可以付费使用,避免重复制造的浪费,这个就叫做<strong>享元/分享模式</strong><br>
            <br>            
            <a href="#20240507"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240507:天鹅丹(筑基丹)<br> 
            小熊用青铜炉炼制的第一颗丹药就是天鹅丹(筑基丹),它有三个版本.<br>
            第一个版本是<strong>代理版本</strong>,服用丹药之后会出现绝对理智的代理神魂控制你的身体进行筑基操作,稳定高效,但是缺少了对于心智的磨砺<br>
            第二个版本是<strong>装饰版本</strong>,服用丹药之后会出现各种保护身体的灵力,保证身体不会奔溃,从而筑基,优点是得到了磨砺,但是很多人心理奔溃了依然会失败<br>
            第三个版本是<strong>适配器版本</strong>,服用丹药之后会自动根据当前需要能量传递灵气,确保稳定的筑基,缺点是如果根基较差则会筑基不够完美,导致后期升级困难<br>      
            <a href="#20240509"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240509:守卫傀儡剑一<br> 
            丹药素材耗尽了,需要出去购买,最近的百草园都有几万公里,小熊只好离家去买药去了,首先给家里的防卫傀儡剑一下达防卫<strong>命令</strong>进入防守<strong>状态</strong>,
            访问者名单写在<strong>备忘录</strong>上,没有访问权限的<strong>访问者</strong>一律禁止进入.为了防止出现语言不通的问题,安装了语言<strong>解释器</strong>,
            又设定了远程<strong>观察</strong>模式,这样只要一有异动就会报警发送更新信息到存储中,回家可以查看记录的信息,为了防止碰到处理不了的问题,
            又设置了<strong>责任链</strong>,当剑一解决不了会提交给青铜炉的灵体炉一处理,这些模块都是通过<strong>中介者</strong>购买的不同守卫<strong>策略</strong>模块,
            为了以后得扩展性,还安装了<strong>迭代器</strong>模块,方便以后更新,安装了<strong>模板方法</strong>模块允许自定义模块.这样终于准备好了,可以出发去百草园了<br>
            <a href="#20240510"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240510:可以联网的炉一<br>
            炉一也有<strong>策略</strong>模块,比较特殊的是他的<strong>命令</strong>是可以联网下达的,通过DNS解析服务一层层<strong>责任链</strong>传达到指定的<strong>观察者</strong>网络中,
            从而实现更加方便的远程控制.<br> 
        </nav>
        <header class="header">设计模式之禅</header>
        <article id="1"><h2 class="chapter">1 单一职责原则</h2>
            <section id="1.1">1.1 我是"牛"类,我可以担任多职吗</section>
            <p></p>
            <section id="1.2">1.2 绝杀技,打破你的传统思维</section>
            <p></p>
            <section id="1.3">1.3 我单纯,所以我快乐</section>
            <p></p>
        </article>
        <article id="2"><h2 class="chapter">2 里氏替换原则</h2>
            <section id="2.1">2.1 爱恨纠葛的父子关系</section>
            <p></p>
            <section id="2.2">2.2 纠纷不断,规则压制</section>
            <p></p>
        </article>
        <article id="3"><h2 class="chapter">3 依赖倒置原则</h2>
            <section id="3.1">3.1 依赖倒置原则的定义</section>
            <p></p>
            <section id="3.2">3.2 言而无信,你太需要契约</section>
            <p></p>
            <section id="3.3">3.3 依赖的三种写法</section>
            <p></p>
        </article>
        <article id="4"><h2 class="chapter">4 接口隔离原则</h2>
            <section id="4.1">4.1 接口隔离原则的定义</section>
            <p></p>
            <section id="4.2">4.2 美女何其多,观点个不同</section>
            <p></p>
            <section id="4.3">4.3 保证接口的纯洁性</section>
            <p></p>
        </article>
        <article id="5"><h2 class="chapter">5 迪米特法则</h2>
            <section id="5.1">5.1 迪米特法则的定义</section>
            <p></p>
            <section id="5.2">5.2 我的知识你知道得越少越好</section>
            <p></p>
        </article>
        <article id="6"><h2 class="chapter">6 开闭原则</h2>
            <section id="6.1">6.1 开闭原则的定义</section>
            <p></p>
            <section id="6.2">6.2 开闭原则的庐山真面目</section>
            <p></p>
            <section id="6.3">6.3 为什么要采用开闭原则</section>
            <p></p>
            <section id="6.4">6.4 如恶化使用开闭原则</section>
            <p></p>
        </article>
        <article id="7"><h2 class="chapter">7 单例模式</h2>
            <section id="7.1">7.1 我是皇帝我独苗</section>
            <p></p>
            <section id="7.2">7.2 单例模式的定义</section>
            <p></p>
            <section id="7.3">7.3 单例模式的应用</section>
            <p></p>
            <section id="7.4">7.4 单利模式的扩展</section>
            <p></p>
        </article>
        <article id="8"><h2 class="chapter">8 工厂方法模式</h2>
            <section id="8.1">8.1 女娲造人的故事</section>
            <p></p>
            <section id="8.2">8.2 工厂方法模式的定义</section>
            <p></p>
            <section id="8.3">8.3 工厂方法模式的应用</section>
            <p></p>
            <section id="8.4">8.4 工厂方法模式的扩展</section>
            <p></p>
        </article>
        <article id="9"><h2 class="chapter">9 抽象工厂模式</h2>
            <section id="9.1">9.1 女娲的失误</section>
            <p></p>
            <section id="9.2">9.2 抽象工厂模式的定义</section>
            <p></p>
            <section id="9.3">9.3 抽象工厂模式的应用</section>
            <p></p>
        </article>
        <article id="10"><h2 class="chapter">10 模板方法模式</h2>
            <section id="10.1">10.1 辉煌工程-制造悍马</section>
            <p></p>
            <section id="10.2">10.2 模板方法模式的定义</section>
            <p></p>
            <section id="10.3">10.3 模板方法模式的应用</section>
            <p></p>
            <section id="10.4">10.4 模板方法模式的扩展</section>
            <p></p>
        </article>
        <article id="11"><h2 class="chapter">11 建造者模式</h2>
            <section id="11.1">11.1 变化是永恒的</section>
            <p></p>
            <section id="11.2">11.2 建造者模式的定义</section>
            <p></p>
            <section id="11.3">11.3 建造者模式的应用</section>
            <p></p>
            <section id="11.4">11.4 建造者模式的扩展</section>
            <p></p>
        </article>
        <article id="12"><h2 class="chapter">12 代理模式</h2>
            <section id="12.1">12.1 我是游戏至尊</section>
            <p></p>
            <section id="12.2">12.2 代理模式的定义</section>
            <p></p>
            <section id="12.3">12.3 代理模式的应用</section>
            <p></p>
            <section id="12.4">12.4 代理模式的扩展</section>
            <p></p>
        </article>
        <article id="13"><h2 class="chapter">13 原型模式</h2>
            <section id="13.1">13.1 个性化电子账单</section>
            <p></p>
            <section id="13.2">13.2 原型模式的定义</section>
            <p></p>
            <section id="13.3">13.3 原型模式的应用</section>
            <p></p>
            <section id="13.4">13.4 原型模式的注意事项</section>
            <p></p>
        </article>
        <article id="14"><h2 class="chapter">14 中介者模式</h2>
            <section id="14.1">14.1 进销存管理是这个样子的吗</section>
            <p></p>
            <section id="14.2">14.2 中介者模式的定义</section>
            <p></p>
            <section id="14.3">14.3 中介者模式的应用</section>
            <p></p>
            <section id="14.4">14.4 中介者模式的实际应用</section>
            <p></p>
        </article>
        <article id="15"><h2 class="chapter">15 命令模式</h2>
            <section id="15.1">15.1 项目经理也难当</section>
            <p></p>
            <section id="15.2">15.2 命令模式的定义</section>
            <p></p>
            <section id="15.3">15.3 命令模式的应用</section>
            <p></p>
            <section id="15.4">15.4 命令模式的扩展</section>
            <p></p>
        </article>
        <article id="16"><h2 class="chapter">16 责任链模式</h2>
            <section id="16.1">16.1 古代妇女的枷锁-"三从四德"</section>
            <p></p>
            <section id="16.2">16.2 责任链模式的定义</section>
            <p></p>
            <section id="16.3">16.3 责任链模式的应用</section>
            <p></p>
        </article>
        <article id="17"><h2 class="chapter">17 装饰模式</h2>
            <section id="17.1">17.1 罪恶的成绩单</section>
            <p></p>
            <section id="17.2">17.2 装饰模式的定义</section>
            <p></p>
            <section id="17.3">17.3 装饰模式应用</section>
            <p></p>
        </article>
        <article id="18"><h2 class="chapter">18 策略模式</h2>
            <section id="18.1">18.1 刘备江东娶妻,赵云他容易吗</section>
            <p></p>
            <section id="18.2">18.2 策略模式的定义</section>
            <p></p>
            <section id="18.3">18.3 策略模式的应用</section>
            <p></p>
            <section id="18.4">18.4 策略模式的扩展</section>
            <p></p>
        </article>
        <article id="19"><h2 class="chapter">19 适配器模式</h2>
            <section id="19.1">19.1 业务发展-上帝才能控制</section>
            <p></p>
            <section id="19.2">19.2 适配器模式的定义</section>
            <p></p>
            <section id="19.3">19.3 适配器模式的应用</section>
            <p></p>
            <section id="19.4">19.4 适配器模式的扩展</section>
            <p></p>
        </article>
        <article id="20"><h2 class="chapter">20 迭代器模式</h2>
            <section id="20.1">20.1 整理项目信息-苦差事</section>
            <p></p>
            <section id="20.2">20.2 迭代器模式的定义</section>
            <p></p>
            <section id="20.2">20.3 迭代器模式的应用</section>
            <p></p>
        </article>
        <article id="21"><h2 class="chapter">21 组合模式</h2>
            <section id="21.1">21.1 公司的人事架构是这样的吗</section>
            <p></p>
            <section id="21.2">21.2 组合模式的定义</section>
            <p></p>
            <section id="21.3">21.3 组合模式的应用</section>
            <p></p>
            <section id="21.4">21.4 组合模式的扩展</section>
            <p></p>
        </article>
        <article id="22"><h2 class="chapter">22 观察者模式</h2>
            <section id="22.1">22.1 韩非子身边的卧底是谁派来的</section>
            <p></p>
            <section id="22.2">22.2 观察者模式的定义</section>
            <p></p>
            <section id="22.3">22.3 观察者模式的应用</section>
            <p></p>
            <section id="22.4">22.4 观察者模式的扩展</section>
            <p></p>
        </article>
        <article id="23"><h2 class="chapter">23 门面模式</h2>
            <section id="23.1">23.1 我要投递信件</section>
            <p></p>
            <section id="23.2">23.2 门面模式的定义</section>
            <p></p>
            <section id="23.3">23.3 门面模式的应用</section>
            <p></p>
            <section id="23.4">23.4 门面模式的注意事项</section>
            <p></p>
        </article>
        <article id="24"><h2 class="chapter">24 备忘录模式</h2>
            <section id="24.1">24.1 如此追女孩子,你还不乐</section>
            <p></p>
            <section id="24.2">24.2 备忘录模式的定义</section>
            <p></p>
            <section id="24.3">24.3 备忘录模式的应用</section>
            <p></p>
            <section id="24.4">24.4 备忘录模式的扩展</section>
            <p></p>
        </article>
        <article id="25"><h2 class="chapter">25 访问者模式</h2>
            <section id="25.1">25.1 员工的隐私何在</section>
            <p></p>
            <section id="25.2">25.2 访问者模式的定义</section>
            <p></p>
            <section id="25.3">25.3 访问者模式的应用</section>
            <p></p>
            <section id="25.4">25.4 访问者模式的扩展</section>
            <p></p>
        </article>
        <article id="26"><h2 class="chapter">26 状态模式</h2>
            <section id="26.1">26.1 城市的纵向发展功臣-电梯</section>
            <p></p>
            <section id="26.2">26.2 状态模式的定义</section>
            <p></p>
            <section id="26.3">26.3 状态模式的应用</section>
            <p></p>
        </article>
        <article id="27"><h2 class="chapter">27 解释器模式</h2>
            <section id="27.1">27.1 四则运算你会吗</section>
            <p></p>
            <section id="27.2">27.2 解释器模式的定义</section>
            <p></p>
            <section id="27.3">27.3 解释器模式的应用</section>
            <p></p>
        </article>
        <article id="28"><h2 class="chapter">28 享元模式</h2>
            <section id="28.1">28.1 内存溢出,司空见惯</section>
            <p></p>
            <section id="28.2">28.2 享元模式的定义</section>
            <p></p>
            <section id="28.3">28.3 享元模式的应用</section>
            <p></p>
            <section id="28.4">28.4 享元模式的应用</section>
            <p></p>
        </article>
        <article id="29"><h2 class="chapter">29 桥梁模式</h2>
            <section id="29.1">29.1 我有一个梦想</section>
            <p></p>
            <section id="29.2">29.2 桥梁模式的定义</section>
            <p></p>
            <section id="29.3">29.3 桥梁模式的应用</section>
            <p></p>
        </article>
        <article id="30" ><p class="chapter">30 创建类模式大PK</p>
            <p>
                <p class="timeStamp" id="20240505">20240505开始</p>
                <strong>创建类模式有哪些?</strong><br>
                创建类模式包括:工厂方法模式,抽象工厂模式,建造者模式,单例模式和原型模式.<br>
                共性:都能提供对象的创建和管理职责.<br>
                <br>
                单例模式:保持在内存中只有唯一的一个对象.<br>
                <figure>
                    <img src="Resources/img/30-01-单例模式通用UML类图.png" alt="单例模式通用UML类图">
                    <p>
                        Ensure a class has only one instance,and provide a global point of access to it.<br>
                        确保一个类只有一个实例对象,并且提供一个全局点来访问他.<br>
                    </p>
                </figure>
                <br>
                原型模式:要求新对象的产生都要通过复制原型.<br>
                <figure>
                    <img src="Resources/img/30-02-原型模式通用UML类图.png" alt="原型模式通用UML类图">
                    <p>
                        Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.<br>
                        用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象<br>
                    </p>
                </figure>
                <br>
                工厂方法模式:工厂提供一个创建对象的接口,根据传入不同的类创建不同的对象.<br>
                <figure>
                    <img src="Resources/img/30-03-工厂方法模式UML.png" alt="工厂方法模式">
                    <p>
                        Define an interface for creating an object,but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses.<br>
                        定义一个用于创建对象的接口,但是让子类来决定哪个类实例化.工厂方法让类的实例化延迟到其子类.<br>
                    </p>
                </figure>
                <br>
                抽象工厂模式:两个维度的划分,不同工厂一个维度,不同产品一个维度.<br>
                <figure>
                    <img src="Resources/img/30-04-抽象工厂模式UML.png" alt="抽象工厂模式">
                    <p>
                        Provide an interface for creating families of related or dependent objects without specifying their concrete classes.<br>
                        为创建一组相关或互相依赖的对象提供一个接口,而且无须指定他们的具体类.<br>
                    </p>
                </figure>
                <br>
                建造者模式:针对不同次序结果不同的产品,让建造者负责设置顺序创建对象,建造者再聚合成导演对象.<br>
                <figure>
                    <img src="Resources/img/30-05-建造者模式UML.png" alt="建造者模式">
                    <p>
                        Separate the construction of a complex object from its representation so that the same construction process can create different representations.<br>
                        将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.<br>
                    </p>
                </figure>
            </p>
            <section id="30.1" class="section">30.1 工厂方法模式VS建造者模式</section>
            <p class="timeStamp" id="20240506">20240506开始</p>
            <p>
                <p>
                    <strong>两个模式之间的侧重点不同</strong><br>
                    工厂模式:侧重于不同产品的产生.<br>
                    <figure>
                        <img src="Resources/img/30-06-工厂方法超人.png" alt="工厂方法超人">
                        <p>
                            工厂方法超人侧重于通过接口对不同类型的超人进行分类.工厂负责生产不同的超人对象<br>
                            关注的是产品的整体,产品具有相似的功能和架构(接口控制).<br>
                        </p>
                    </figure>
                    <br>
                    建造者模式:侧重于不同产品的生产顺序的不同.<br>
                    <figure>
                        <img src="Resources/img/30-07-建造者模式超人.png" alt="建造者模式超人">
                        <p>
                            配合使用了模板方法,建造者负责定义了需要哪些部件,具体建造者则按照自己想要的顺序实现不同对象的组合,并返回这个对象.<br>
                            导演类则是通过聚合不同的建造者进一步封装了建造者,方便调用.<br>
                            关注的重点是产品的制造顺序,最后返回产品,可以认为建造者模式比工厂模式更细致,控制力更强一点(同样也意味着需要知道的更多).<br>
                        </p>
                    </figure>
                    <br>
                    <strong>总结</strong><br>
                    意图不同:工厂方法侧重产品整体,建造者侧重构建顺序.<br>
                    产品的复杂度不同:工厂方法创建一般都是单一性质的产品,而建造者往往创造的是复杂产品,不同顺序会带来不同的产品.所以工厂方法粒度比较粗,建造者模式粒度比较细.<br>
                    根据上面两个区别,很容易可以意识到,针对复杂产品使用建造者模式,针对普通的单一产品使用工厂方法.<br>
                    <p class="timeStamp">20240505结束</p>
                </p>
            </p>
            <section id="30.2" class="section">30.2 抽象工厂模式VS建造者模式</section>
            <p>
                <figure>
                    <img src="Resources/img/30-08-抽象工厂生产汽车.png" alt="抽象工厂生产汽车">
                    <p>
                        两个维度,一个是品牌,一个是型号,型号由ICar接口的两个抽象子类AbsBenz和AbsBMW决定<br>
                        一个是品牌,由CarFactory工厂来控制,然后在实现当中进行工厂的划分<br>
                        这样就实现了两个维度,品牌和型号<br>
                    </p>
                </figure>
                <figure>
                    <img src="Resources/img/30-09-建造者模式生产汽车.png" alt="建造者模式生产汽车">
                    <p>
                        建造者的侧重点则完全不同,Director导演类是车间主任,调用不同的建造者来得到不同构件步骤创建不同的汽车产品<br>
                    </p>
                </figure>
                <strong>总结</strong><br>
                抽象工厂模式在工厂方法模式再进了一步,增加了第二个维度工厂的区分,是更高层次的封装,建造者则侧重单个产品的构件步骤,所以更灵活<br>
            </p>
        </article>
        <article id="31"><h2 class="chapter">31 结构类模式大PK</h2>
            <p>
                <strong>有哪些结构类模式?</strong><br>
                结构类模式包括:适配器模式,桥梁/桥接模式,组合模式,装饰模式,门面/外观模式,享元模式和代理模式.<br>
                共性:通过组合类或对象产生更大结构以适应更高层次的逻辑.<br>
                适配器模式:继承需要适配的对象,然后用他的数据来实现当前需要接口的方法<br>
                <figure>
                    <img src="Resources/img/31-01-适配器模式.png" alt="适配器模式">
                    <p>
                        Convert the interface of a class into another interface clients expece.Adapter lets classes work togethere that couldn;t otherwise because of incompatible interfaces.<br>
                        翻译:将一个类的接口变换成客户端所期待的另一种接口,从而使原本因接口不匹配而无法再一起工作的两个类能够在一起工作<br>
                    </p>
                </figure>
                桥梁/桥接模式:将抽象和实现分离,多个实现聚合成抽象类的实例对象.<br>
                <figure>
                    <img src="Resources/img/31-02-桥接模式.png" alt="桥接模式">
                    <p>
                        Decouple an abstraction from its implementation so that the  two can vary independently<br>
                        翻译:将抽象和实现解耦.使得两者可以独立地变化.<br>
                    </p>
                </figure>
                组合模式:通过树状的递归结构,让使用单个对象和使用一组对象一样.<br>
                <figure>
                    <img src="Resources/img/31-03-组合模式.png" alt="组合模式">
                    <p>
                        Compose objects into tree structures to represent part-shole hierarchies.Composite lets clients treat individual objects and compositions of objects niformly<br>
                        翻译:将对象组合成树形结构以表示"部分-整体"的层次结构,使得用户对单个对象和组合对象的使用具有一致性.<br>
                    </p>
                </figure>
                装饰模式:装饰者和被修饰对象继承相同的抽象类,装饰者传入修饰对象进行修改,所以可以独立发展.<br>
                <figure>
                    <img src="Resources/img/31-04-装饰模式.png" alt="装饰模式">
                    <p>
                        Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.<br>
                        翻译:动态的给一个对象添加一些额外的职责.就增加功能来说,装饰模式相比生成子类更为灵活.<br>
                    </p>
                </figure>
                门面/外观模式:汇总子系统的业务逻辑,客户端调用外观对象,外观对象委托给各个子对象执行<br>
                <figure>
                    <img src="Resources/img/31-05-外观模式.png" alt="外观模式">
                    <p>
                        Provide a unified interface to a set of interfaces in a subsystem.Facade defines a higher-level interface that makes the subsystem easier to use.<br>
                        翻译:要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行.<br>
                    </p>
                </figure>
                享元模式:通过抽象提取到一个共享池,获取对象会先获取这个池当中的对象.<br>
                <figure>
                    <img src="Resources/img/31-06-享元模式.png" alt="享元模式">
                    <p>
                        Use sharing to support large numbers of fine-grained objects efficiently.<br>
                        翻译:使用共享对象可以有效地支持大量的细粒度的对象.<br>
                    </p>
                </figure>
                代理模式:需要通过代理对象才能获取真实对象的访问,增加了一个中间控制过程<br>
                <figure>
                    <img src="Resources/img/31-07-代理模式.png" alt="代理模式">
                    <p>
                        定义:Provide a surrogate or placeholder for another object to control access to it.<br>
                        翻译:为其他对象提供一种代理以控制对这个对象的访问.<br>
                    </p>
                </figure>
                总结:<br>
                适配器做的是两个不同类之间的翻译配合工作,装饰者模式是给一个类增加新的功能;<br>
                桥接模式是让多个实现来组成当前类,组合模式是递归的树状结构组合成当前类;<br>
                外观模式是让一个类的负责汇总功能给别人看,代理模式是给真实类增加一个中间人;<br>
                享元模式是把共用的部分抽取到公共池当中,客户访问池里面的不同的对象;<br>                
            </p>
            <p>
                <section id="31.1" class="section">31.1 代理模式VS装饰模式</section>
                <p class="timeStamp" id="20240507">20240507开始</p>
                <p>
                    <div class="paragraph">31.1.1 代理模式</div>
                    <figure>
                        <img src="Resources/img/31-1-01-代理模式运动员.png" alt="代理模式运动员">
                        <p>
                            IRunner运动员接口<br>
                            定义运动员具有的抽象方法,跑步<br>
                            Runner具体运动员<br>
                            实现跑步方法<br>
                            RunnerAgent运动员代理<br>
                            在构造函数传递实现了IRunner接口的对象,也就是Runner具体运动员,然后自行安排是否执行.<br>
                            Client客户端对象<br>
                            客户端对象通过访问代理对象访问具体运动员<br>
                        </p>
                    </figure>
                    <p>
                        代理在不改变接口的前提下,对过程进行控制,在这个例子当中就是对运动员是否跑步进行控制<br>
                    </p>
                    <div class="paragraph">31.1.2 装饰模式</div>
                    <figure>
                        <img src="Resources/img/31-1-02-装饰模式运动员.png" alt="装饰模式运动员">
                        <p>
                            IRunner接口和Runner具体运动员和代理模式一样<br>
                            RunnerWithJet装饰类<br>
                            同样的在构造函数传递了运动员,通过委托增强了某个方法的功能,而不是决定这个功能是否执行<br>
                            Client客户端对象<br>
                            调用的装饰过后的Runner对象(也就是RunnerWithJet对象)就会执行装饰类新增的部分和原始Runner对象的run部分<br>
                        </p>
                    </figure>
                    <p>
                        装饰在不修改原始类的情况下,给他新增了功能,他不能决定被代理的方法是否执行<br>
                    </p>
                    <div class="paragraph">31.1.3 对比</div>
                    <p>
                        代理模式是把当前的行为火功能委托给其他对象执行,代理类负责接口限定过滤等等.<br>
                        装饰模式是在要保证接口不变的情况下加强火衰弱类的功能,但是不考虑准入条件判断和参数过滤等.<br>
                    </p>                   
                </p>
            </p>
            <p>
                <section id="31.2" class="section">31.2 装饰模式VS适配器模式</section>
                <p>
                    <div class="paragraph">31.2.1 用装饰模式描述丑小鸭</div>
                    <figure>
                        <img src="Resources/img/31-2-01-装饰丑小鸭.png" alt="装饰丑小鸭">
                        <p>
                            Swan天鹅接口<br>
                            天鹅会飞,会叫,有漂亮的外表三个方法<br>
                            UglyDuckling丑小鸭实现类<br>
                            丑小鸭是一只天鹅,实现Swan天鹅接口的方法,只是小时候不太像<br>
                            Decorator装饰抽象类<br>
                            装饰类把传入的实现Swan天鹅接口的对象(丑小鸭)重新修饰天鹅的方法<br>
                            BeautifyAppearance外观,StrongBehavior行为修饰实现类<br>
                            分别对外观和行为进行修饰,丑小鸭对象在修饰过后就变成了真正的白天鹅<br>
                        </p>
                    </figure>
                    <p>
                        装饰模式关注了对象功能的强化,是对原始对象的行为和属性的修正和加强.<br>
                    </p>
                    <div class="paragraph">31.2.2 用适配器模式实现丑小鸭</div>
                    <figure>
                        <img src="Resources/img/31-2-02-适配丑小鸭.png" alt="适配丑小鸭">
                        <p>
                            丑小鸭本质是白天鹅WhiteSwan继承Swan接口,鸭妈妈的孩子都继承了Duck接口,绝大多数孩子都是Dcukling鸭对象
                            ,只有UglyDuckling丑小鸭,他实际上是白天鹅,鸭妈妈按照Duck接口的标准觉得她很丑陋.强行把一只鹅对象看成了鸭对象<br>
                        </p>
                    </figure>
                    <p>
                        侧重点是不同类之间的匹配,在例子当中就是把天鹅当鸭子看,自然觉得哪哪都不对劲<br>
                    </p>
                    <div class="paragraph">31.2.3 对比</div>
                    <p>
                        意图不同:<br>
                        装饰模式的意图是对象的加强或衰减<br>
                        适配器模式的意图是不同对象的转化(或者说换个视角看待问题)<br>
                        <br>
                        针对对象不同:<br>
                        装饰模式真的是有相同接口或父类的对象,是同宗的<br>
                        适配器模式则是两个不同的对象之间进行转换翻译<br>
                        <br>
                        使用场景不同:<br>
                        装饰模式在任何情况都可以使用,而适配器模式通常是在一个成熟项目中的补救措施.<br>
                        <br>
                        扩展性不同:<br>
                        装饰模式是可以随便扩展的,不想要不装饰就好了,适配器模式那就不一样了,一旦适配了,想要撤销就要考虑后面所有引用了适配之后的类的对象了<br>
                    </p>
                </p>
            </p>            
        </article>
        <article id="32"><h2>32 行为类模式大PK</h2>
            <p class="timeStamp" id="20240509">20240509开始</p>
            <section id="32.0"><p class="section">32.0 总览</p>
                <div>
                    <p class="paragraph">1.封装变化</p>
                    <p>
                        策略模式Stategy:实现策略接口的都能用<br>                                                                  
                        <figure>
                            <img src="Resources/img/32-01-策略模式类图.png" alt="策略模式">
                            <p>
                                Define a family of algorithms,encapsulate each one,and make them interchangeable.<br>
                                翻译:定义一组算法,将每个算法都封装起来,并且使它们之间可以互换.<br>
                                Context通过变量引用实现Startegy接口的策略实现类.因为是通过接口引用的,所以所有符合接口的都可以方便的调用.<br>
                            </p>
                        </figure>
                        <br> 
                        状态模式State:用状态来封装不同的表现,自己维护一个状态类context<br> 
                        <figure>
                            <img src="Resources/img/32-02-状态模式类图.png" alt="状态模式">
                            <p>
                                Allow an objet to alter its behavior when its internal state changes.The object will appear to change its class.<br>
                                翻译:当一个对象内在状态改变时允许其改变行为,这个对象看起来像改变了其类<br>
                                Context通过变量引用继承State抽象类的状态实现类,通过切换不同的状态实现不同的行为,和策略模式相比不同之处<br>
                                State当中定义了Context的存储方便子类来调用<br>
                                ConcreteState当中定义了不同状态之间的切换<br>
                                Context通过不同的状态实现不同的功能<br>
                            </p>
                        </figure>
                        <br> 
                        中介者模式Mediator:抽象同事类Colleage存了中介,所有具体同事类通过中介找其他人沟通<br> 
                        <figure>
                            <img src="Resources/img/32-03-中介者模式类图.png" alt="中介者模式">
                            <p>
                                Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.<br>
                                翻译:用一个中介者对象封装一系列的对象交互,中介者使各对象不需要显示地相互作用,从而使其松耦合,可以独立的改变它们之间的交互.<br>
                                Mediator中介者抽象类,Colleague同事抽象类通过构造器知道中介者,所有同事之间的沟通都是通过唯一的具体中介对象ConcreteMediator<br>
                            </p>
                        </figure>
                        <br> 
                        迭代器模式Iterator:容器实现容器的添加删除元素和返回迭代器功能,迭代器实现遍历的功能<br> 
                        <figure>
                            <img src="Resources/img/32-04-迭代器模式类图.png" alt="迭代器模式">
                            <p>
                                Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.<br>
                                翻译:提供一种方法访问一个容器对象中各个元素,而又不需要暴露该对象的内部细节.<br>
                                ConcreteIterator迭代器对象通过抽象类Iterator规定的方法实现对于容器对象的遍历.<br>
                                ConcreteAggregate聚合容器类则是在实现容器本身的添加删除元素等功能的基础上实现Aggregate抽象类定义的返回迭代器对象功能.<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">2.传递对象作为参数</p>
                    <p>
                        访问者模式Visitor:通过访问者访问每一个对象<br>
                        <figure>
                            <img src="Resources/img/32-05-访问者模式类图.png" alt="访问者模式">
                            <p>
                                Represent an operation to be performed on the elements of an object structure.Vistor lets you define a new operation without changing the classes of the elements on which it operates.<br>
                                翻译:封装一些作用域某种数据结构中的各元素的操作,它可以在不改变数据结构的前提下定义作用域这些元素的新的操作.<br>
                                具体元素对象设置访问权限,引用访问者对象的访问方法来执行不同的操作.<br>
                            </p>
                        </figure>
                        <br>
                        备忘录模式Memento:通过管理员获得自己存档<br>
                        <figure>
                            <img src="Resources/img/32-06-备忘录模式类图.png" alt="备忘录模式">
                            <p>
                                Without violating encapsulation,capture adn externalize an object's internal state so that the object can be restored to this state later.<br>
                                翻译:在不破坏封装的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样之后就可以将该对象恢复到原先保存的状态.<br>
                                Originator发起人自己创建Memento备忘录对象,管理员Caretaker存储,保管,提供备忘录对象<br>
                            </p>
                        </figure>
                        <br>
                        命令模式Command:通过命令类来访问具体执行者对象<br>
                        <figure>
                            <img src="Resources/img/32-07-命令模式类图.png" alt="命令模式">
                            <p>
                                Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests,and support undoable operations.<br>
                                翻译:将一个请求封装成一个对象,从而让你使用不同的请求把客户端参数化,对请求排队或者记录请求日志,可以提供命令的撤销和恢复功能.<br>
                                Invoker执行者持有ConcreteCommand命令对象,命令对象持有Receiver具体执行者,执行具体的逻辑<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">3.其他</p>
                    <p>
                        责任链模式Chain:递归定义一系列不同级别的责任人来处理某个事情<br>                     
                        <figure>
                            <img src="Resources/img/32-08-责任链模式.png" alt="责任链模式">
                            <p>
                                Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until an object handles it.<br>                                翻译:使多个对象都有机会处理请求,从而避免了请求的发送者和接收者之间的耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,只掉有对象处理它为止.
                                Handler执行者完成两件事,定义自己能够处理的等级,然后处理,然后设置下一个执行者<br>
                            </p>
                        </figure>
                        <br>
                        解释器模式Interpreter:对不同的字符分别进行不同解释来执行(需要有固定模式)<br>
                        <figure>
                            <img src="Resources/img/32-09-解释器模式.png" alt="解释器模式">
                            <p>
                                Given a language,define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.<br>
                                翻译:给定一门语言,定义它的文法的一种表示,并定义一个解释器,该解释器使用该表示来解释语言中的句子.<br>
                                TerminalExpression终结符表达式负责处理多个NoneterminalExpression非终结符表达式之间的关系,类比成算术就是,终结符是+-*/等运算,非终结符就是数字,这个模式通过一个一个拆解一个一个分析字符来处理.<br>
                            </p>
                        </figure>
                        <br>
                        观察者模式Observer:设置观察者列表来实现更新通知<br>
                        <figure>
                            <img src="Resources/img/32-10-观察者模式.png" alt="观察者模式">
                            <p>
                                Define a one-to-many dependency between objects so that when one object changes, all its dependents are notified and updated automatically.<br>
                                翻译:定义对象间一种一对多的依赖关系,使得每当一个对象改变状态,则所有依赖于它的对象都会得到通知并被自动更新.<br>
                                Subject主题对象持有Observer观察者列表,可以添加删除列表中的观察者对象,当自身改变的时候可以通知所有的观察者,而观察者则是被通知后就更新<br>
                            </p>
                        </figure>
                        <br>
                        模板方法模式TemplateMethod:父类定义框架,子类实现具体执行<br>
                        <figure>
                            <img src="Resources/img/32-11-模板方法模式.png" alt="模板方法模式">
                            <p>
                                定义:Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain seteps of an algorithm without changing the algorithm's structure.<br>
                                翻译:定义一个操作中的算法框架,将一些步骤延迟到子类中,使得子类可以不改变一个算法的结构既可以重定义该算法的某些特定步骤.<br>
                                在抽象类当中定义框架(模板方法),框架中的方法(基本方法)则抽象延迟到子类实现.<br>
                            </p>
                        </figure>
                    </p>
                </div>
            </section><p></p>
            <p class="timeStamp" id="20240510">20240510开始</p>
            <section id="32.1"><p class="section">32.1 命令模式VS策略模式</p>
                <div>
                    <p class="paragraph">1.前言</p>
                    <p>
                        策略模式意图:认为算法是一个独立,不可拆分的原子业务,让算法独立,可以互相替换,让行为的变换独立于拥有行为的客户.<br>
                        命令模式意图:对行为的分解,将行为分解成了执行行为(命令)要求执行者(接收者)处理,让命令和行为互相独立,这样就可以独立的对命令或者行为进行替换了.<br>
                        对比:命令模式比策略模式封装更细<br>
                    </p>
                    <p class="paragraph">2.策略模式实现压缩算法</p>
                    <p>
                        <figure>
                            <img src="Resources/img/32-12-策略模式压缩算法.png" alt="策略模式压缩算法">
                            <p>
                                Zip和Gzip类实现接口Algorithm定义的压缩和解压缩方法<br>
                                context内容对象通过引用Algorithm定义的接口方法来引用具体算法实现类.<br>
                                Client客户端通过Context引用具体算法<br>
                                在这个过程当中,算法被封装成了接口,所以只要实现接口的具体算法都可以实现互换,独立的实现算法被认为是原子业务<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">3.命令模式实现压缩算法</p>
                    <p>
                        <figure>
                            <img src="Resources/img/32-13-命令模式压缩算法.png" alt="命令模式压缩算法">
                            <p>
                                AbstractCmd通过聚合实例引用了实现IReceiver接口的接收者对象ZipReceiver和GzipReceiver,具体命令*Cmd类则是对不同的方法进行区分,
                                Invoker通过接口关联具体命令,具体命令通过抽象命令找到执行者执行
                                在这个过程中所有命令方法被独立成了对象,通过抽象命令封装.<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">4.对比</p>
                    <p>
                        策略模式关注算法的替换<br>
                        命令模式关注请求者和执行者的解耦,让请求者知道命令就好了,具体算法隐藏<br>
                    </p>
                </div>
            </section>
            <section id="32.2"><p class="section">32.2 策略模式VS状态模式</p>
                <p class="paragraph">1.前言</p>
                <p>
                    策略模式封装的是算法,算法之间是没有交互的<br>
                    状态模式封装的事状态,状态之间是存在切换关系的<br>
                </p>
                <p class="paragraph">2.策略模式实现人生</p>
                <p>
                    <figure>
                        <img src="Resources/img/32-14-策略模式人生.png" alt="策略模式人生">
                        <p>
                            WorkAlgorithm人生算法抽象类定义了算法框架<br>
                        </p>
                    </figure>
                </p>
                <p class="paragraph">3.状态模式实现人生</p>
                <p>
                    <figure>
                        <img src="Resources/img/32-15-状态模式人生.png" alt="状态模式人生">
                        <p>
                            Human对象持有状态,并按照状态执行,允许其他对象设置状态<br>
                            HumanState抽象状态类可以给某个Human对象设置状态<br>
                            具体状态对象则是实现当前状态的逻辑,定义(设置)下一个状态<br>
                        </p>
                    </figure>
                </p>
                <p class="paragraph">4.小结</p>
                <p>
                    环境角色的职责不同:<br>
                    策略模式的Context环境对象只是委托对象,负责替换算法;<br>
                    状态模式的Human环境对象不仅仅要委托给具体状态执行,还需要登记状态的变化,辅助具体状态对象完成状态的切换工作;<br>
                    <br>
                    解决问题的重点不同:<br>
                    策略模式重点是算法切换,状态模式则是状态的切换.<br>
                </p>

            </section>
            <section id="32.3"><p class="section">32.3 观察者模式VS责任链模式</p>
                <p class="paragraph">1. 责任链模式DNS解析</p>
                <p>
                    <figure>
                        <img src="Resources/img/32-16-责任链DNS.png" alt="责任链DNS">
                        <p>
                            DnsServer抽象类定义DNS的框架<br>
                            具体的DNS服务按照责任链的模式,上海的解决不了就传到中国DNS,中国的不行再传到顶级DNS这个责任模式<br>
                        </p>
                    </figure>
                </p>
                <p class="paragraph">2. 观察责任链模式DNS解析</p>
                <p>
                    <figure>
                        <img src="Resources/img/32-17-责任链观察者DNS.png" alt="责任链观察者DNS">
                        <p>
                            添加了观察者模式的观察者和接收者,顶级域名是不负责反馈的,只是传递信息让子DNS服务商更新信息,这个传递通过观察者模式处理.<br>
                        </p>
                    </figure>
                </p>
            </section>
        </article>
        <article id="33"><h2>33 跨战区PK</h2>
            <section id="33.1">32.1 策略模式VS桥梁模式</section><p></p>
            <section id="33.2">32.2 门面模式VS中介者模式</section><p></p>
            <section id="33.3">32.3 包装模式群PK</section><p></p>
        </article>
        <article id="34"><h2>34 命令模式+责任链模式</h2>
            <section id="34.1">1.1 我是"牛"类,我可以担任多职吗</section>
            <p></p>
        </article>
        <article id="35"><h2>35 工厂方法模式+策略模式</h2>
            <section id="35.1">1.1 我是"牛"类,我可以担任多职吗</section>
            <p></p>
        </article>
        <article id="36"><h2>36 观察者模式+中介者模式</h2>
            <section id="36.1">1.1 我是"牛"类,我可以担任多职吗</section>
            <p></p>
        </article>
        <article id="37"><h2>37 MVC框架</h2>
            <section id="37.1">1.1 我是"牛"类,我可以担任多职吗</section>
            <p></p>
        </article>
        <article id="38"><h2>38 新模式</h2>
            <section id="38.1">1.1 我是"牛"类,我可以担任多职吗</section>
            <p></p>
        </article>
        <footer><a href="../../../../index.html">首页</a></footer>
        <script>
                // 读取存储的滚动位置并滚动到该位置  
            const scrollPositionKey = 'scrollPosition';  // 定义滚动位置变量
            const storedScrollPosition = localStorage.getItem(scrollPositionKey); // localStorage是存在用户设备上
            
            window.onload = function()  // 读取窗口的时候就回滚到上次位置
            {
                if (storedScrollPosition)  // 如果滚动位置存在 
                {  
                    window.scrollTo(0, parseInt(storedScrollPosition)); // 滚动到这个位置 
                } 
            } 
            
            // 监听滚动事件并存储位置  
            window.addEventListener('scroll', () => 
            {  
                const scrollPosition = window.scrollY || window.pageYOffset || document.body.scrollTop + (document.documentElement && document.documentElement.scrollTop || 0);  
                localStorage.setItem(scrollPositionKey, scrollPosition);  
            });
        </script>
    </body>
</html>
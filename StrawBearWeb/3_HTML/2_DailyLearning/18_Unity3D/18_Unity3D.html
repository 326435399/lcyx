<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="UTF-8">
        <meta name="StrawBear" content="width=device-width,initial-scale=1.0">
        <title>Untiy3D游戏开发</title>
        <link rel="stylesheet" href="../../../1_CSS/basicStyle.css">
    </head>   
    <body>
        <aside>
            <ul>
                <li><a href="#1">1 基础知识</a>
                    <ul>
                        <li><a href="#1.1">1.1 Unity简介</a></li>
                        <li><a href="#1.2">1.2 跨平台</a></li>
                        <li><a href="#1.3">1.3 协作开发</a></li>
                        <li><a href="#1.4">1.4 Unity版本</a></li>
                        <li><a href="#1.5">1.5 Package Manager</a></li>
                        <li><a href="#1.6">1.6 示例项目与发布</a></li>
                        <li><a href="#1.7">1.7 Unity服务</a></li>
                    </ul>
                </li>
                <li><a href="#2">2 编辑器的结构</a>
                    <ul>
                        <li><a href="#2.1">2.1 UnityHub</a></li>
                        <li><a href="#2.2">2.2 编辑器布局</a></li>
                        <li><a href="#2.3">2.3 Project视图</a></li>
                        <li><a href="#2.4">2.4 Hierarchy视图</a></li>
                        <li><a href="#2.5">2.5 Inspector视图</a></li>
                        <li><a href="#2.6">2.6 Scene视图</a></li>
                        <li><a href="#2.7">2.7 Game视图</a></li>
                        <li><a href="#2.8">2.8 导航栏视图</a></li>
                    </ul>
                </li>
                <li><a href="#3">3 游戏脚本</a>
                    <ul>
                        <li><a href="#3.1">3.1 C#运行时</a></li>
                        <li><a href="#3.2">3.2 C#与引擎交互</a></li>
                        <li><a href="#3.3">3.3 游戏对象</a></li>
                        <li><a href="#3.4">3.4 游戏组件</a></li>
                        <li><a href="#3.5">3.5 游戏脚本</a></li>
                        <li><a href="#3.6">3.6 脚本的生命周期</a></li>
                        <li><a href="#3.7">3.7 脚本的管理</a></li>
                        <li><a href="#3.8">3.8 脚本序列化</a></li>
                        <li><a href="#3.9">3.9 脚本属性</a></li>
                        <li><a href="#3.10">3.10 协程任务</a></li>
                        <li><a href="#3.11">3.11 通过脚本操作对象和组件</a></li>
                    </ul>
                </li>
                <li><a href="#4">4 UGUI</a>
                    <ul>
                        <li><a href="#4.1">4.1 游戏界面</a></li>
                        <li><a href="#4.2">4.2 界面布局</a></li>
                        <li><a href="#4.3">4.3 Canvas组件</a></li>
                        <li><a href="#4.4">4.4 Atlas</a></li>
                        <li><a href="#4.5">4.5 事件系统</a></li>
                    </ul>
                </li>
                <li><a href="#5">5 UI Toolkit</a>
                    <ul>
                        <li><a href="#5.1">5.1 UI Toolkit简介</a></li>
                        <li><a href="#5.2">5.2 UI Builder编辑器</a></li>
                        <li><a href="#5.3">5.3 UI组件</a></li>
                        <li><a href="#5.4">5.4 事件系统</a></li>
                        <li><a href="#5.5">5.5 进阶技巧</a></li>
                        <li><a href="#5.6">5.6 UI Toolkit渲染</a></li>
                        <li><a href="#5.7">5.7 UI Toolkit学习资料</a></li>
                    </ul>
                </li>
                <li><a href="#6">6 2D游戏开发</a>
                    <ul>
                        <li><a href="#6.1">6.1 Sprite Renderer组件</a></li>
                        <li><a href="#6.2">6.2 Tile地图</a></li>
                        <li><a href="#6.3">6.3 2D物理系统</a></li>
                        <li><a href="#6.4">6.4 像素风</a></li>
                        <li><a href="#6.5">6.5 精灵形状</a></li>
                        <li><a href="#6.6">6.6 精灵编辑器</a></li>
                    </ul>
                </li>
                <li><a href="#7">7 3D游戏开发</a>
                    <ul>
                        <li><a href="#7.1">7.1 Renderer</a></li>
                        <li><a href="#7.2">7.2 游戏对象和资源</a></li>
                        <li><a href="#7.3">7.3 动画系统</a></li>
                        <li><a href="#7.4">7.4 3D物理系统</a></li>
                        <li><a href="#7.5">7.5 输入系统</a></li>
                        <li><a href="#7.6">7.6 Transform组件</a></li>
                    </ul>
                </li>
                <li><a href="#8">8 静态对象</a>
                    <ul>
                        <li><a href="#8.1">8.1 光照贴图</a></li>
                        <li><a href="#8.2">8.2 反射探针</a></li>
                        <li><a href="#8.3">8.3 遮挡剔除</a></li>
                        <li><a href="#8.4">8.4 静态合批</a></li>
                        <li><a href="#8.5">8.5 导航网格</a></li>
                    </ul>
                </li>
                <li><a href="#9">9 持久化数据</a>
                    <ul>
                        <li><a href="#9.1">9.1 Excel</a></li>
                        <li><a href="#9.2">9.2 SQLite</a></li>
                        <li><a href="#9.3">9.3 JSON</a></li>
                        <li><a href="#9.4">9.4 文件的读取与写入</a></li>
                        <li><a href="#9.5">9.5 XML</a></li>
                        <li><a href="#9.6">9.6 YAML</a></li>
                        <li><a href="#9.7">9.7 生成代码</a></li>
                    </ul>
                </li>
                <li><a href="#10">10 多媒体</a>
                    <ul>
                        <li><a href="#10.1">10.1 音频</a></li>
                        <li><a href="#10.2">10.2 视频</a></li>
                    </ul>
                </li>
                <li><a href="#11">11 Netcode与网络编程</a>
                    <ul>
                        <li><a href="#11.1">11.1 UnityWebRequest</a></li>
                        <li><a href="#11.2">11.2 Socket</a></li>
                        <li><a href="#11.3">11.3 Netcode</a></li>
                    </ul>
                </li>
                <li><a href="#12">12 渲染管线</a>
                    <ul>
                        <li><a href="#12.1">12.1 SRP</a></li>
                        <li><a href="#12.2">12.2 URP</a></li>
                        <li><a href="#12.3">12.3 SRP Batch</a></li>
                        <li><a href="#12.4">12.4 渲染技术</a></li>
                        <li><a href="#12.5">12.5 自定义渲染管线</a></li>
                    </ul>
                </li>
                <li><a href="#13">13 DOTS1.0</a>
                    <ul>
                        <li><a href="#13.1">13.1 DOTS的组成</a></li>
                        <li><a href="#13.2">13.2 游戏对象转到ECS</a></li>
                        <li><a href="#13.3">13.3 实体组件</a></li>
                        <li><a href="#13.4">13.4 系统</a></li>
                        <li><a href="#13.5">13.5 Job</a></li>
                        <li><a href="#13.6">13.6 Burst</a></li>
                        <li><a href="#13.7">13.7 渲染</a></li>
                    </ul>
                </li>
                <li><a href="#14">14 扩展编辑器</a>
                    <ul>
                        <li><a href="#14.1">14.1 扩展Project视图</a></li>
                        <li><a href="#14.2">14.2 扩展Hierarchy视图</a></li>
                        <li><a href="#14.3">14.3 扩展Inspector视图</a></li>
                        <li><a href="#14.4">14.4 扩展Scene视图</a></li>
                        <li><a href="#14.5">14.5 扩展Game视图</a></li>
                        <li><a href="#14.6">14.6 导航栏扩展</a></li>
                        <li><a href="#14.7">14.7 查看源代码</a></li>
                    </ul>
                </li>
                <li><a href="#15">15 资源管理</a>
                    <ul>
                        <li><a href="#15.1">15.1 编辑器模式</a></li>
                        <li><a href="#15.2">15.2 运行模式</a></li>
                        <li><a href="#15.3">15.3 AssetBundle</a></li>
                        <li><a href="#15.4">15.4 代码编译</a></li>
                        <li><a href="#15.5">15.5 Shader编译</a></li>
                        <li><a href="#15.6">15.6 美术资源管理</a></li>
                    </ul>
                </li>
                <li><a href="#16">16 自动化与打包</a></li>
                <li><a href="#17">17 代码优化</a></li>
                <li><a href="#18">18 通用案例与优化</a></li>
            </ul>
        </aside>
        <nav>
            <a href="#20240505"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240505:ECS系统<br>           
            小熊在游戏当中创建了一只军队,现在每个小队都自由控制所有的装备和作战,这导致了战斗力及其低下,为了加强军队的战斗力引入了ECS系统.<br>
            把相同的武器装备全部集中在了一起,这些武器就是组件Component,所有的武器统一在武器库管理,这个武器库就是实体Entities.<br>
            最后所有的士兵统一接受指挥部(Job System)的调度,每个士兵的任务Job同步执行,这样就极大的提高了军队的战斗力.<br>
            <a href="#20240507"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240507:ECS的实现1<br>
            我们首先使用<strong>创作模式</strong>生产所有的武器,然后准备<strong>实体组件结构体</strong>仓库规划来对这些武器分门别类,
            按照不同的<strong>Archetype原型 </strong>武器种类作为分类依据,每个武器种类由一个一个的<strong>Chunk簇</strong>(一套这个类型武器)组成,
            最后统一交由武器管理部<strong>System系统</strong>控制来控制存储和支取武器,支取的方式是先找对应原型,然后遍历每个簇来获得想要的指定武器<br>
            <a href="#20240513"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240513:扩展视口<br>
            为了方便我们系统的使用,我们对<strong>View视口</strong>进行扩展,根据原本的视口元素位置关系来创建新的Rect按钮元素<br>
            <a href="#20240514"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240514:武器库监视器<br>
            武器管理部会<strong>监听</strong>所有武器的出入库情况,他有三个监控界面<strong>Hierarchy,Scene,Inspector</strong>这三个界面都可以通过
            不同的方法来设置显示方式,方便进行可视化管理<br>
            <a href="#20240515"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240515:武器库监视器<br>
            <strong>Game和导航栏</strong>也是可以自定义修改的,Unity的C#源代码可以在Git上面获取,这样我们就拥有了自定义一切的能力了<br>
            <a href="#20240516"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240516:资源控制<br>
            针对不同类型的武器资源,需要有不同的出入库处理情况,这就是资源控制<br>
            <a href="#20240520"><img style="width:18pt" src="Resources/other/跳转.jpg" alt="跳转"></a>20240520:AB<br>
            为了减轻一次性处理大量资源的压力,可以通过<strong>AB包</strong>(就是一个容器),把武器划分,然后再统一存放<br>
        </nav>
        <header><p class="header">Untiy3D游戏开发</p></header>
        <article id="1"><p class="chapter">1 基础知识</p>
            <section id="1.1">1.1 Unity简介</section><p></p>
            <section id="1.2">1.2 跨平台</section><p></p>
            <section id="1.3">1.3 协作开发</section><p></p>
            <section id="1.4">1.4 Unity版本</section><p></p>
            <section id="1.5">1.5 Package Manager</section><p></p>
            <section id="1.6">1.6 示例项目与发布</section><p></p>
            <section id="1.7">1.7 Unity服务</section><p></p>
        </article>
        <article id="2"><p class="chapter">2 编辑器的结构</p>
            <section id="2.1">2.1 UnityHub</section><p></p>
            <section id="2.2">2.2 编辑器布局</section><p></p>
            <section id="2.3">2.3 Project视图</section><p></p>
            <section id="2.4">2.4 Hierarchy视图</section><p></p>
            <section id="2.5">2.5 Inspector视图</section><p></p>
            <section id="2.6">2.6 Scene视图</section><p></p>
            <section id="2.7">2.7 Game视图</section><p></p>
            <section id="2.8">2.8 导航栏视图</section><p></p>
        </article>
        <article id="3"><p class="chapter">3 游戏脚本</p>
            <section id="3.1">3.1 C#运行时</section><p></p>
            <section id="3.2">3.2 C#与引擎交互</section><p></p>
            <section id="3.3">3.3 游戏对象</section><p></p>
            <section id="3.4">3.4 游戏组件</section><p></p>
            <section id="3.5">3.5 游戏脚本</section><p></p>
            <section id="3.6">3.6 脚本的生命周期</section><p></p>
            <section id="3.7">3.7 脚本的管理</section><p></p>
            <section id="3.8">3.8 脚本序列化</section><p></p>
            <section id="3.9">3.9 脚本属性</section><p></p>
            <section id="3.10">3.10 协程任务</section><p></p>
            <section id="3.11">3.11 通过脚本操作对象和组件</section><p></p>
        </article>
        <article id="4"><p class="chapter">4 UGUI</p>
            <section id="4.1">4.1 游戏界面</section><p></p>
            <section id="4.2">4.2 界面布局</section><p></p>
            <section id="4.3">4.3 Canvas组件</section><p></p>
            <section id="4.4">4.4 Atlas</section><p></p>
            <section id="4.5">4.5 事件系统</section><p></p>
        </article>
        <article id="5"><p class="chapter">5 UI Toolkit</p>
            <section id="5.1">5.1 UI Toolkit简介</section><p></p>
            <section id="5.2">5.2 UI Builder编辑器</section><p></p>
            <section id="5.3">5.3 UI组件</section><p></p>
            <section id="5.4">5.4 事件系统</section><p></p>
            <section id="5.5">5.5 进阶技巧</section><p></p>
            <section id="5.6">5.6 UI Toolkit渲染</section><p></p>
            <section id="5.7">5.7 UI Toolkit学习资料</section><p></p>
        </article>
        <article id="6"><p class="chapter">6 2D游戏开发</p>
            <section id="6.1">6.1 Sprite Renderer组件</section><p></p>
            <section id="6.2">6.2 Tile地图</section><p></p>
            <section id="6.3">6.3 2D物理系统</section><p></p>
            <section id="6.4">6.4 像素风</section><p></p>
            <section id="6.5">6.5 精灵形状</section><p></p>
            <section id="6.6">6.6 精灵编辑器</section><p></p>
        </article>
        <article id="7"><p class="chapter">7 3D游戏开发</p>
            <section id="7.1">7.1 Renderer</section><p></p>
            <section id="7.2">7.2 游戏对象和资源</section><p></p>
            <section id="7.3">7.3 动画系统</section><p></p>
            <section id="7.4">7.4 3D物理系统</section><p></p>
            <section id="7.5">7.5 输入系统</section><p></p>
            <section id="7.6">7.6 Transform组件</section><p></p>
        </article>
        <article id="8"><p class="chapter">8 静态对象</p>
            <section id="8.1">8.1 光照贴图</section><p></p>
            <section id="8.2">8.2 反射探针</section><p></p>
            <section id="8.3">8.3 遮挡剔除</section><p></p>
            <section id="8.4">8.4 静态合批</section><p></p>
            <section id="8.5">8.5 导航网格</section><p></p>
        </article>
        <article id="9"><p class="chapter">9 持久化数据</p>
            <section id="9.1">9.1 Excel</section><p></p>
            <section id="9.2">9.2 SQLite</section><p></p>
            <section id="9.3">9.3 JSON</section><p></p>
            <section id="9.4">9.4 文件的读取与写入</section><p></p>
            <section id="9.5">9.5 XML</section><p></p>
            <section id="9.6">9.6 YAML</section><p></p>
            <section id="9.7">9.7 生成代码</section><p></p>
        </article>
        <article id="10"><p class="chapter">10 多媒体</p>
            <section id="10.1">10.1 音频</section><p></p>
            <section id="10.2">10.2 视频</section><p></p>
        </article>
        <article id="11"><p class="chapter">11 Netcode与网络编程</p>
            <section id="11.1">11.1 UnityWebRequest</section><p></p>
            <section id="11.2">11.2 Socket</section><p></p>
            <section id="11.3">11.3 Netcode</section><p></p>
        </article>
        <article id="12"><p class="chapter">12 渲染管线</p>
            <section id="12.1">12.1 SRP</section><p></p>
            <section id="12.2">12.2 URP</section><p></p>
            <section id="12.3">12.3 SRP Batch</section><p></p>
            <section id="12.4">12.4 渲染技术</section><p></p>
            <section id="12.5">12.5 自定义渲染管线</section><p></p>
        </article>
        <article id="13"><p class="chapter">13 DOTS1.0</p>
            <p class="timeStamp" id="20240505">20240505学习</p>
            <section id="13.1"><p class="section">13.1 DOTS的组成</p>
                <p>
                    DOTS的全称是Data-Oriented Tech Stack多线程式数据导向型技术栈,原理是充分利用CPU多核处理器,让游戏处理的速度更快,更高效.<br>
                    DOTS主要由ECS+Job System+Burst Compiler三部分组成.可以任意组合使用<br>
                    ECS:实体组件系统用于默认编写高性能代码.<br>
                    Job System:任务系统,用于高效运行多线程代码<br>
                    Burst Compiler:编译加速器用于生成高度优化的本地代码,提供单指令多数据SIMD.<br>
                    
                    <p class="paragraph">13.1.1 ECS简介</p>
                    <p>
                        ECS的全称是Entity(实体) Component(组件) System(系统).<br>
                        概念始于GDC 2017当中守望先锋游戏架构的分享.<br>
                        实体组件是一个结构体struct,它本身不需要GC(垃圾回收),只保存数据而不保存逻辑,不对外提供方法.<br>
                        传统的做法是通过游戏对象找到组件,再执行逻辑,实体组件则是通过系统来找组件,系统规定了组件的组合结构,因为在内存中是连续的,所以查询遍历速度非常快<br>
    
                        <figure>
                            <img src="Resources/img/13-1-1-1-传统内存排布.png" alt="传统内存排布">
                            <p>
                                传统游戏当中,大量游戏对象和脚本互相引用,导致在内存中排布非常混乱,CPU的高速缓存命中率几乎为零,这就导致每次想要获取新的数据
                                CPU都不得不从内存当中重新加载新的数据到高速缓存当中,这就导致了执行效率不会高.<br>
                                另外一个问题是传统的组件非常的庞大,很多时候仅仅需要很少的几个数据,但是不得不把整个组件都加载,
                                大量没用数据的加载导致每次CPU都需要从内存加载很多数据,导致效率低下.<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/13-1-1-2-E代码.png" alt="E代码">
                            <p>
                                首先组件必须是结构体,Script组件自身是无法驱动的,必须通过ECSSystem来驱动.<br>
                                Entities.ForEach会遍历指定的Script组件类型,系统会把所有满足的Script组件全部给连续保存在缓存或内存中<br>
                                下一帧OnUpdate执行因为已经全部连续加载了,所以遍历会非常快(就像以前机械硬盘的磁盘整理一样)<br>
                                ScheduleParallel就会对所有的Script组件并行执行(这样极大的利用了CPU的并行能力)<br>
                                实体对象也是可以绑定多个实体组件的,这样会把这一些组件都在内存中连续保存<br>
                            </p>
                        </figure>
                    </p>
    
                    <p class="paragraph">13.1.2 Job System简介</p>
                    <p>
                        Unity传统游戏对象提供的核心API是不支持多线程的,为了实现多线程就有了Job System.<br>
                        DOTS专门提供了com.unity.entities.graphics包用于更新DOTS渲染<br>
                        Job System在底层安全的处理了死锁竞争问题,每个Job都是一个单独的任务,由Job System统一处理,Job之间可以设置并行,串行,等待主线程等等
                        比较糟心的事Unity的API大部分都不能再Job中使用<br>
                    </p>
                    
                    <p class="paragraph">13.1.3 Burst Compiler简介</p>
                    <p>
                        Burst Compiler底层是一个基于LLVM的编译器,我们在Job前面会加上[BurstCompile]标记开启Burst编译.<br>
                        原本的Unity代码引擎部分是用C++写的,为了简化难度引入了C#语言来开发,早期的.NET不支持多平台,Unity就采用了开源的Mono来跨平台执行DLL代码<br>
                        后来需要支持的平台越来越多,又引入了IL2CPP在打包的时候把DLL转换成C++代码并引入贝姆垃圾收集器.这么一大堆自然就效率上不去了<br>
                        经过测试.NetCore的性能和IL2CPP差不多,比C++慢1/2,比Mono快2-3倍,在采用IL2CPP方案打开BurstCompiler后性能比C++还要快,所以效率极高<br>
                        Unity计划在2024年放弃Mono,采用.NETCore方案来实现多平台编译<br>
                    </p>
                    
                    <p class="paragraph">13.1.4 安装</p>
                    <p>
                        <figure>
                            <img src="Resources/img/13-1-4-1-安装包.png" alt="安装包">
                            <p>                           
                                com.unity.entities(实体组件库)<br>
                                com.unity.entities.graphics(实体组件渲染包)<br>
                                com.unity.burst(Burst编译库)<br>
                                com.unity.netcode(网络编程)<br>
                                com.unity.physics(物理)<br>
                                com.unity.collections(HPC#容器)<br>
                                com.unity.logging(异步日志方案)<br>
                            </p>
                        </figure>
                        
                    </p>               
                </p>
                
    
                <section id="13.2">
                    <p class="timeStamp" id="20240507">20240507学习</p>
                    <p class="section">13.2 游戏对象转到ECS</p>                
                    <div>
                        <p class="paragraph">13.2.1 传统的对象与组件</p>
                        <p>
                            <figure>
                                <img src="Resources/img/13-2-1-1-传统组件方式.png" alt="传统组件方式">
                                <p>
                                    传统情况每个游戏对象就是一个容器,可以通过组合的方式不断给对象添加更多的功能,通过组合的方式产生不同的游戏对象<br>
                                </p>
                            </figure>
                        </p>
                        <p class="paragraph">13.2.2 Entity(实体)</p>
                        <p>
                            <figure>
                                <img src="Resources/img/13-2-2-1-实体组件方式.png" alt="实体组件方式">
                                <p>
                                    实体组件则只能保存数据,是一个结构体,值类型数据,不提供任何的逻辑,这样组件和组件之间完全不存在耦合,统一通过System来驱动.由于实体组件在内存中会尽可能地将相同组件排列在一起,所以缓存命中率会非常高,CPU的高速缓存也能用上,遍历速度非常快.<br>
                                </p>
                            </figure>
                        </p>
                        <p class="paragraph">13.2.3 Archetype(原型)</p>
                        <p>
                            <figure>
                                <img src="Resources/img/13-2-3-1-Archetype.png" alt="Archetype">
                                <p>
                                    实体对象可以任意绑定实体组件,反正只是数据.会把有相同组件的对象创建一组原型Archetype<br>
                                </p>
                            </figure>
                            <figure>
                                <img src="Resources/img/13-2-3-2-chunk.png" alt="chunk">
                                <p>
                                    原型里面由若干簇Chunk数组组成,每个簇16KB大小,相同的组件会以数组的形式保存在一起,例如我们可以通过遍历每个Chunk,然后找个每个position修改数据就可以统一修改position,需要注意的是怎么给对象分组(不同原型)<br>
                                </p>
                            </figure>
                        </p>
                        <p class="paragraph">13.2.4 Component(组件)</p>
                        <p>
                            实体组件需要继承IComponentData接口,但本身是一个struct对象,无法在编辑模式下使用.<br>
                            所以我们需要两类对象,一类是创作对象,使用传统游戏对象方式开发,在运行游戏时转换成ECS的方式运行,另一类是程序对象,本身是运行时动态生成的.<br>
                            <figure>
                                <img src="Resources/img/13-2-4-1-SubScene.png" alt="SubScene">
                                <p>
                                    创建一个子场景,右侧的勾如果勾选就会子场景里面的对象还是安装传统的情况制作,取消勾选会转换成ECS方式运行<br>
                                </p>
                            </figure>
                            <figure>
                                <img src="Resources/img/13-2-4-2-创作模式脚本.png" alt="创作模式脚本">
                                <p>
                                    准备传统脚本,实体组件和转换器<br>
                                </p>
                            </figure>
                            <figure>
                                <img src="Resources/img/13-2-4-3-创作模式下.png" alt="创作模式下">
                                <p>
                                    在创作者模式下,依然还是传统的方式使用功能脚本,构建逻辑<br>
                                </p>
                            </figure>
                            <figure>
                                <img src="Resources/img/13-2-4-4-ECS模式.png" alt="ECS模式">
                                <p>
                                    取消勾选,就会自动转换成ECS数据结构(通过我们准的Baker方法转换)<br>
                                </p>
                            </figure>
                        </p>
                        <p class="paragraph">13.2.5 System(系统)</p>
                        <p>
                            <figure>
                                <img src="Resources/img/13-2-5-1-System系统.png" alt="System系统">
                                <p>
                                    统一通过System系统来控制,通过遍历来找<br>
                                </p>
                            </figure>
                            <figure>
                                <img src="Resources/img/13-2-5-2-System结果.gif" alt="System结果">
                                <p>
                                    实现的结果,标记了我们脚本的被放到一个原型了,然后我们遍历就找到所有的数据然后操作就可以了,方块没有标记,所以没有移动<br>
                                </p>
                            </figure>
                        </p>
                    </div>
                </section>
    
                <section id="13.3">13.3 实体组件</section><p></p>
                <section id="13.4">13.4 系统</section><p></p>
                <section id="13.5">13.5 Job</section><p></p>
                <section id="13.6">13.6 Burst</section><p></p>
                <section id="13.7">13.7 渲染</section><p></p>

            </section>          
        </article>
        <p class="timeStamp" id="20240513">20240513学习</p>
        <article id="14"><p class="chapter">14 扩展编辑器</p>
            <section id="14.1"><p class="section">14.1 扩展Project视图</p>
                <div>
                    <p class="paragraph">14.1.1 扩展右键菜单</p>
                    <p>
                        Unity编辑器由五大基本视图组成,Project,Hierarchy,Inspector,Scene,Game<br>
                        有两种方式来扩展:一种是扩展内置视图中的元素,一种是扩展我们自己写的脚本和自定义Windows窗口面板<br>
                        <figure>
                            <img src="Resources/img/14-1-1-菜单创建.png" alt="菜单创建">
                            <p>
                                Unity将位于Editor文件夹内的代码仅限制在编辑模式使用,正式打包是不包含的.代码创建了一个菜单<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.1.2 创建脚本模板</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-2-操作逻辑1.png" alt="操作逻辑1">
                            <p>
                                创建菜单,获取路径<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/14-1-3-操作逻辑2.png" alt="操作逻辑2">
                            <p>
                                在这个路径写用我们新模板创建的脚本<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.1.3 扩展布局</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-4-扩展按钮.png" alt="扩展按钮">
                            <p>
                                扩展按钮<br>
                                <figure>
                                    <img src="Resources/img/14-1-5-扩展按钮结果样式.png" alt="扩展按钮结果样式">
                                </figure>
                            </p>
                        </figure>
                    </p>
                    <p class="timeStamp" id="20240514">20240514学习</p>
                    <p class="paragraph">14.1.4 监听资源导入</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-6-资源导入.png" alt="资源导入">
                            <p>
                                继承AssetPostprocessor类,OnPreXXX方法是导入前事件,OnPostXXX是导入后事件,然后通过assetImporter属性获取导入资产的引用转换成想要修改的对应XXXXImporter对象,进行修改资产设置<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.1.5 监听资源修改事件</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-7-资源监听.png" alt="资源监听">
                            <p>
                                InitializeOnLoadMethod 全局监听方法<br>
                                IsOpenForEdit 监听“双击鼠标左键，打开资源”事件<br>
                                OnWillCreateAsset 监听“资源即将被创建”事件<br>
                                OnWillSaveAssets 监听“资源即将被保存”事件<br>
                                OnWillMoveAsset 监听“资源即将被移动”事件<br>
                                OnWillDeleteAsset 监听“资源即将被删除”事件<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.1.6 自定义资源导入类型</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-8-自定义资源导入.png" alt="自定义资源导入">
                            <p>
                                Unity允许添加自定义资源导入类型来识别自定义格式的资源,逻辑很简单<br>
                                1.通过ScriptedImporter注册监听<br>
                                2.扩展ScriptedImporter抽象类,覆盖OnImportAsset方法<br>
                            </p>
                        </figure>
                    </p>
                </div>
            </section>
            <section id="14.2"><p class="section">14.2 扩展Hierarchy视图</p>
                <div>
                    <p class="paragraph">14.2.1 扩展菜单</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-9-创建菜单.png" alt="创建菜单">
                            <p>
                                GameObject路径下面定义的菜单会创建在Hierarchy的右键菜单里面<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.2.2 扩展布局</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-10-修改布局.png" alt="修改布局">
                            <p>
                                和Project窗口的修改方式一样,都是通过渲染回调来设置的,比较特殊的是这个Button直接传递了一张图片来作为Button而不是文字<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.2.3 自动选择游戏对象</p>
                    <p>
                        可以通过Selection.activeGameObject选择指定的激活的游戏对象<br>
                        也可以通过Selection.objects选择某个资源或游戏对象<br>
                    </p>
                </div>
            </section>
            <section id="14.3"><p class="section">14.3 扩展Inspector视图</p>
                <div>
                    <p class="paragraph">14.3.1 扩展原生组件</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-11-扩展按钮.png" alt="扩展按钮">
                            <p>
                                扩展组件只能在原生组件的最上面或者最下面,比较遗憾的是不是所有组件都公开,都能继承覆盖<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.3.2 扩展继承组件</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-12-不能继承的扩展.png" alt="不能继承的扩展">
                            <p>
                                针对没有公开的编辑器,通过反射的方式拿到对象创建并修改<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.3.3 限制组件编辑</p>
                    <p>
                        在GUI当中使用GUI.enabled = false;限制下面的GUI处于不可使用状态直到GUI.enabled=true;代码块<br>
                    </p>
                    <p class="paragraph">14.3.4 Context菜单</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-13-扩展弹出菜单.png" alt="扩展弹出菜单">
                            <p>
                                可以通过CONTEXT/unity组件名 来给指定组件添加右键菜单,这样是全局的,可以写在任何类当中,另外一种写在当前脚本组件中的则是通过[ContextMenu("菜单内容")]指定<br>
                            </p>
                        </figure>
                    </p>
                </div>
            </section>
            <section id="14.4"><p class="section">14.4 扩展Scene视图</p>
                <div>
                    <p class="paragraph">14.4.1 工具栏扩展</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-14-工具栏扩展.png" alt="工具栏扩展">
                            <p>
                                EditorTool用来生成工具栏按钮<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.4.2 辅助元素</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-15-辅助元素.png" alt="辅助元素">
                            <p>
                                通过OnDrawGizmos系列来绘制<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.4.3 辅助UI</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-16-辅助UI.png" alt="辅助UI">
                            <p>
                                OnSceneGUI修改即可<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.4.4 常驻辅助UI</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-17-常驻UI.png" alt="常驻UI">
                            <p>
                                常驻UI需要覆盖SceneView.duringSceneGui这个委托<br>
                            </p>
                        </figure>
                    </p>
                </div>
            </section>

            <p class="timeStamp" id="20240515">20240515学习</p>
            <section id="14.5"><p class="section">14.5 扩展Game视图</p>
                <div>
                    <figure>
                        <img src="Resources/img/14-1-18-Game视口GUI.png" alt="Game视口GUI">
                        <p>
                            比较需要注意的是ExecuteInEditMode是一个常用的标识.<br>
                        </p>
                    </figure>
                </div>
            </section>
            <section id="14.6"><p class="section">14.6 导航栏扩展</p>
                <div>
                    <p class="paragraph">14.6.1 自定义菜单</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-19-菜单.png" alt="菜单">
                            <p>
                                自定义菜单和其他事一样的,比较特殊的是优先级超过10会减10然后在上方增加一个下划线<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.6.2 菜单项自动执行</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-20-脚本执行.png" alt="脚本执行">
                            <p>
                                可以通过EditorApplication类来执行一些特殊的菜单操作<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.6.3 导航条</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-21-导航条修改.png" alt="导航条修改">
                            <p>
                                也是通过反射的方式拿到的,通过OnGUI修改绘制<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.6.4 标题栏扩展</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-22-标题栏.png" alt="标题栏">
                            <p>
                                通过finishedDefaultHeaderGUI委托,修改实现<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">14.6.5 默认面板</p>
                    <p>
                        <figure>
                            <img src="Resources/img/14-1-23-其他资源.png" alt="其他资源">
                            <p>
                                对默认面板的修改,OnInspectorGUI<br>
                            </p>
                        </figure>
                    </p>
                </div>
            </section>
            <section id="14.7"><p class="section">14.7 查看源代码</p>
                <div>
                    <figure>
                        <img src="Resources/img/14-1-24-Unity源码.png" alt="Unity源码">
                        <p>
                            在官网可以看到Unity的C#代码的源码,C++的引擎源码估计是不给看了<br>
                        </p>
                    </figure>
                </div>
            </section>
        </article>
        <p class="timeStamp" id="20240516">20240516学习</p>
        <article id="15"><p class="chapter">15 资源管理</p>
            <section id="15.1"><p class="section">15.1 编辑器模式</p>
                <p class="paragraph">15.1.1 游戏资源</p>
                <p>
                    <figure>
                        <img src="Resources/img/15-1-游戏资源.png" alt="游戏资源">
                        <p>
                            Unity只会对Asset目录下的资源进行二次生成,使用的是生成的资源而不是原始资产,配套生成的Meta文件里面记录了生成资产的设置参数和GUID(记录和其他资源的关联关系)<br>
                        </p>
                    </figure>
                </p>
                <p class="paragraph">15.1.2 加载资源</p>
                <p>
                    <figure>
                        <img src="Resources/img/15-2-自动生成.png" alt="自动生成">
                        <p>
                            编辑模式下的资源有两类,一种是Unity可以识别的,会根据Meta文件自动转换到资产数据库里面引用,一种是无法识别的,需要自己解析成可以识别的数据或者使用其他工具来使用这些数据<br>
                        </p>
                    </figure>
                    <figure>
                        <img src="Resources/img/15-3-实际引用.png" alt="实际引用">
                        <p>
                            在Windows_Analysis_ImportActivity可以查看导入的资产最终生成到什么地方,大小多少,依赖多少<br>
                        </p>
                    </figure>
                </p>
                <p class="paragraph">15.1.3 卸载资源</p>
                <p>
                    <figure>
                        <img src="Resources/img/15-4-资产卸载.png" alt="资产卸载">
                        <p>
                            因为实际对象是C++创建的,然后C#再持有,所以使用Destroy或者设置null只能释放C#持有的,需要使用Resources.xxx来卸载C++上的内存.<br>
                        </p>
                    </figure>
                </p>
                <p class="paragraph">15.1.4 创建与修改资源</p>
                <p>
                    <figure>
                        <img src="Resources/img/15-5-资产创建.png" alt="资产创建">
                        <p>
                            资产的创建分两大类,一类是原始资产,通常使用File读取创建,一类是Unity引擎资产,使用AssetDatabase来创建<br>
                        </p>
                    </figure>
                </p>
                <p class="paragraph">15.1.5 创建与修改游戏对象</p>
                <p>
                    <figure>
                        <img src="Resources/img/15-6-游戏对象.png" alt="游戏对象">
                        <p>
                            游戏对象GameObject是Object实例化创建之后出现在Hierarchy的对象,而Object对象又是由Prefab或者Scene引用AssetDatabase里面的引擎资源创建的.<br>
                        </p>
                    </figure>
                    <figure>
                        <img src="Resources/img/15-7-创建和修改游戏对象.png" alt="创建和修改游戏对象">
                        <p>
                            通过脚本创建和修改游戏对象,注意实例化和创建的区别<br>
                        </p>
                    </figure>
                </p>

            </section>
            <section id="15.2"><p class="section">15.2 运行模式</p>
                <p class="paragraph">15.2.1 参与打包的资源</p>
                <p>
                    Unity打包的时候会自动删除没有引用的资源,只有Resources和StreamingAssets目录下不管有没有引用都会保留.<br>
                    Resources里面的资源以UnityEngine.Object形式打包,StreamingAssets下的资源以原始文件打包,unity提供的Assetbundle下载包也是原始文件<br>
                </p>
                <p class="paragraph">15.2.2 Resources</p>
                <p>
                    通过Resources.Load和Resources.LoadAsync进行同步和异步资源加载,参数是相对路径,不需要扩展名.<br>
                    如果又多个同名的则要使用LoadAll,Load默认加载第一个符合的<br>
                    shader文件除了Load还可以用Find来加载资源<br>
                </p>
                <p class="paragraph">15.2.3 通过脚本计算依赖</p>
                <p>
                    <figure>
                        <img src="Resources/img/15-8-依赖查询.png" alt="依赖查询">
                        <p>
                            也可以通过右键选择寻找依赖项<br>
                        </p>
                    </figure>
                </p>
                <p class="paragraph">15.2.4 StreamingAssets</p>
                <p>
                    StreamingAssets目录下的文件是原始文件打包,所以只能通过File类或者UnityWebRequest来加载,所以Unity提供了AssetBundle的资源打包方式.<br>
                </p>
                <p class="paragraph">15.2.5 场景资源</p>
                <p>
                    <figure>
                        <img src="Resources/img/15-9-场景依赖.png" alt="场景依赖">
                        <p>
                            为了避免误打包,最后将不需要的场景移除,而不是取消勾选<br>
                        </p>
                    </figure>
                </p>
            </section>

             <p class="timeStamp" id="20240520">20240520学习</p>
            <section id="15.3"><p class="section">15.3 AssetBundle</p>
                <div>
                    <p class="paragraph">15.3.1 设置AB</p>
                    <p>
                        <figure>
                            <img src="Resources/img/15-10-资产设置.png" alt="资产设置">
                            <p>
                                给对象设置好资产名和扩展名<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/15-11-打包.png" alt="打包">
                            <p>
                                使用代码执行打包(如果没有对应的平台支持会打包失败的,有冲突也会打包失败的)<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/15-12-打包结果.png" alt="打包结果">
                            <p>
                                最终打包得到的结果,manifest尾缀的都是记录信息用的(最终可以不需要的),unity3d则是我们打包的对象.<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">15.3.2 设置依赖</p>
                    <p>
                        <figure>
                            <img src="Resources/img/15-13-设置依赖.png" alt="设置依赖">
                            <p>
                                我们创建另外一个立方体,然后引用了相同的材质球CubeMat,打包之后我们分别得到了两个AB包,但是都有重复的CubeMat,有两种处理方式解决这个浪费<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/15-14-方法1.png" alt="方法1">
                            <p>
                                方式1:把两个Cube对象都打包在一起(一样的资源名),这样会自动检测到材质球是重复的,就不会打包两份了.<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/15-15-方法2.png" alt="方法2">
                            <p>
                                方式2:给材质球打成一个AB包,这样也会检测了,依赖另外一个AB包也是不会重复的.<br>
                            </p>
                        </figure>
                    </p>
                    <p class="paragraph">15.3.3 纯脚本打包</p>
                    <p>
                        <figure>
                            <img src="Resources/img/15-16-脚本打包.png" alt="脚本打包">
                            <p>
                                使用脚本来打包,这样更加直观,但是如果打包的很多也很夸张<br>
                            </p>
                        </figure>
                        <figure>
                            <img src="Resources/img/15-17-打包结果.png" alt="打包结果">
                        </figure>
                    </p>
                    <p class="paragraph">15.3.4 差异打包</p>
                    <p>
                        Unity现在支持增量打包和差异打包,前提是不能删除上一次打包的AB文件.<br>
                    </p>
                    <p class="paragraph">15.3.5 AB压缩格式</p>
                    <p>
                        BuildAssetBundleOptions可以设置AB的压缩格式,推荐是使用LZ4格式ChunkBasedCompressionAssetBundle,压缩效率稍微低但是解压和加载快.<br>
                    </p>
                    <p class="paragraph">15.3.6 加载AB</p>
                    <p class="paragraph">15.3.7 内存与卸载</p>
                    <p class="paragraph">15.3.8 场景AB</p>
                    <p class="paragraph">15.3.9 CDN下载流程</p>
                    <p class="paragraph">15.3.10 加载流程</p>
                    <p class="paragraph">15.3.11 多进程AB构建</p>

                </div>
            </section>
            <section id="15.4"><p class="section">15.4 代码编译</p></section>
            <section id="15.5"><p class="section">15.5 Shader编译</p></section>
            <section id="15.6"><p class="section">15.6 美术资源管理</p></section>
        </article>
        <article id="16"><p class="chapter">16 自动化与打包</p>
            <section id="16.1"></section>
        </article>
        <article id="17"><p class="chapter">17 代码优化</p>
            <section id="17.1"></section>
        </article>
        <article id="18"><p class="chapter">18 通用案例与优化</p>
            <section id="18.1"></section>
        </article>
        <footer><a href="../../../../index.html">首页</a></footer>
        <script>
                // 读取存储的滚动位置并滚动到该位置  
            const scrollPositionKey = 'scrollPosition';  // 定义滚动位置变量
            const storedScrollPosition = localStorage.getItem(scrollPositionKey); // localStorage是存在用户设备上
            
            window.onload = function()  // 读取窗口的时候就回滚到上次位置
            {
                if (storedScrollPosition)  // 如果滚动位置存在 
                {  
                    window.scrollTo(0, parseInt(storedScrollPosition)); // 滚动到这个位置 
                } 
            } 
            
            // 监听滚动事件并存储位置  
            window.addEventListener('scroll', () => 
            {  
                const scrollPosition = window.scrollY || window.pageYOffset || document.body.scrollTop + (document.documentElement && document.documentElement.scrollTop || 0);  
                localStorage.setItem(scrollPositionKey, scrollPosition);  
            });
        </script>
    </body>
</html>
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="StrawBear" content="记录一个学习者的过程">
        <title>20240415-21周总结</title>
        <link rel="stylesheet" href="../../1_CSS/basicStyle.css">
    </head>
    <body>
        <header><h1>20240415-21周总结</h1></header>
        <nav>
            <ul>
                <li><a href="#1">1.英语学习</a></li>
                <li><a href="#2">2.计算机图形学--计算机图形学原理(OpenGL)</a></li>
                <li><a href="#3">3.计算机学习-设计模式(Java)</a></li>
                <li><a href="#4">4.Unity学习-HLSL学习</a></li>
                <li><a href="#5">5.计算机学习-深度学习入门(Python)</a></li>
                <li><a href="#6">6.计算机--HTML+CSS+JavaScript</a></li>
                <li><a href="#7">7.数学学习-MIT1801线性代数</a></li>
                <li><a href="#8">8.Unity学习_Unity3D游戏开发(C#)</a></li>
                <li><a href="#9">9.计算机--图形学原理与实践(XAML)</a></li>
                <li><a href="#10">10.美术学习-CG造型基础与创作</a></li>
            </ul>
        </nav>
        <article id="1"><h2>1.英语学习</h2>
            <section><h3>语法点:现在完成时</h3></section>
            <div>
                <h4>1.肯定形式</h4>
                have/has + 过去分词,根据主语的人称和单复数选择have和has(三单选has)<br>
                I have worked here.<br>
                翻译:我在这里工作过.<br>
                <h4>2.否定形式</h4>
                have/has 后面加上not<br>
                I have't worked here.<br>
                翻译:我没在这里工作过<br>
                <h4>3.疑问形式</h4>
                将have.has 提前<br>
                Have I worked here?<br>
                翻译:我以前在这里工作过吗?<br>
            </div>
            <section><h3>翻译逻辑的思考</h3></section>
            <p>
                基本都是主语 + 修饰谓语的词 + 谓语 +宾语的结构逻辑;
                <img src="img/20240421/1_English/01_翻译逻辑.png" alt=""><br>              
            </p>
        </article>
        <article id="2"><h2>2.计算机图形学--计算机图形学原理(OpenGL)</h2>
            <section><h3>练习</h3></section>
            <p>
                1.饼图
                <img src="img/20240421/2_OpenGL/01_饼图.png" alt=""><br>              
                <img src="img/20240421/2_OpenGL/02_饼图结果.png" alt=""><br>  
                2.曲线图            
                <img src="img/20240421/2_OpenGL/03_曲线代码.png" alt=""><br>              
                <img src="img/20240421/2_OpenGL/04_结果.png" alt=""><br>       
                3.三个表
                <img src="img/20240421/2_OpenGL/05_三种不同建表方式的差异.png" alt=""><br>              
                <img src="img/20240421/2_OpenGL/06_疑问怎么需要检测.png" alt=""><br>              
                <img src="img/20240421/2_OpenGL/07_绘制结果.png" alt=""><br>              
                <img src="img/20240421/2_OpenGL/08_obj索引.png" alt=""><br>     
            </p>
        </article>
        <article id="3"><h2>3.计算机学习-设计模式(Java)</h2>
            <section><h3>1.中介者模式</h3></section>
            <p>
                Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.<br>
                翻译:用一个中介者对象封装一系列的对象交互,中介者使各对象不需要显示地相互作用,从而使其松耦合,可以独立的改变它们之间的交互.<br>
                优点:把一对多变成了一对一依赖,降低了类间的耦合<br>
                缺点:中介者会很复杂,同事越多越复杂.<br>
                适用:当多个对象之间耦合逻辑复杂,可以考虑用中介者来简化逻辑<br>
                简单来说就是给了一个中枢系统<br>
                <img src="img/20240421/3_DesignMode/01_中介者模式.png" alt=""><br>
            </p>
            <section><h3>2.命令模式</h3></section>
            <p>
                Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests,and support undoable operations.<br>
                翻译:将一个请求封装成一个对象,从而让你使用不同的请求把客户端参数化,对请求排队或者记录请求日志,可以提供命令的撤销和恢复功能.<br>
                优点:<br>
                1.类间解耦,调用者和接收者没有依赖关系,调用者只需要调用execute,具体执行具体命令类当中定义好了<br>
                2.可扩展性:Command的子类是很容易扩展的<br>
                缺点:随着命令数量的增多,Command子类快速膨胀<br>
                总结:提供一个Invoker作为责任人来沟通,通过命令类来规范命令的执行<br>
                <img src="img/20240421/3_DesignMode/02_命令模式.png" alt=""><br>
            </p>
            <section><h3>3.责任链模式</h3></section>
            <p>
                Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until an object handles it.<br>
                翻译:使多个对象都有机会处理请求,从而避免了请求的发送者和接收者之间的耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,只掉有对象处理它为止.<br>
                优点:请求和处理分离,请求者不需要知道最后是谁处理了任务<br>
                缺点:性能问题,类递归的循环调用方式必然性能消耗是不小的,然后就是调试麻烦,<br>
                通过链条的方式减少单一责任人不执行导致的问题.<br>
                <img src="img/20240421/3_DesignMode/03_责任链模式.png" alt=""><br>

            </p>
            <section><h3>4.装饰模式</h3></section>
            <p>
                Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.<br>
                翻译:动态的给一个对象添加一些额外的职责.就增加功能来说,装饰模式相比生成子类更为灵活.<br>
                优点:<br>
                1.装饰类和被装饰类互相独立,不会相互耦合<br>
                2.装饰模式是继承关系的替代方案<br>
                3.装饰模式可以动态扩展一个实现类的功能.<br>
                缺点:如果装饰了多层,结果会很复杂.不利于调试.<br>
                适用场景:<br>
                需要扩展一个类的功能,或者给一个类附加功能<br>
                需要动态的给一个对象增加功能,后面可以撤销<br>
                需要为一批类统一改装或加装功能<br>
                总结:动态的增加或改装功能<br>
                <img src="img/20240421/3_DesignMode/04_装饰模式.png" alt=""><br>
            </p>
            <section><h3>5.策略模式</h3></section>
            <p>
                Define a family of algorithms,encapsulate each one,and make them interchangeable.<br>
                翻译:定义一组算法,将每个算法都封装起来,并且使它们之间可以互换.<br>
                示例:在上面的例子当中:三个具体策略类就是一组算法,他们有一个公共的策略接口,我们把算法用Context封装起来,这样只要是同样的策略接口,当中的具体实现策略是可以互换的.<br>
                优点:<br>
                1.算法可以自由切换:只要实现抽象策略就成为策略家族的一员,就可以自由切换了<br>
                2.避免使用多重条件判断,策略家族对外提供的访问接口就是封装类,是统一的.需要由其他模块决定何种策略<br>
                3.扩展性良好:只要实现策略接口就可以扩展策略<br>
                缺点:<br>
                1.策略类数量多<br>
                2.策略类都需要暴露,上层模块需要知道有哪些策略,才能决定使用哪一个策略.<br>
                使用场景:<br>
                1.多个类只有在算法或行为上稍有不同的场景<br>
                2.算法需要自由切换的场景<br>
                3.屏蔽算法规则的场景.<br>
                总结:通过统一接口实现的快速互换<br>
                <img src="img/20240421/3_DesignMode/05_策略模式.png" alt=""><br>
            </p>
            <section><h3>6.适配器模式</h3></section>
            <p>
                Convert the interface of a class into another interface clients expece.Adapter lets classes work togethere that couldn;t otherwise because of incompatible interfaces.<br>
                翻译:将一个类的接口变换成客户端所期待的另一种接口,从而使原本因接口不匹配而无法再一起工作的两个类能够在一起工作<br>
                优点:<br>
                1.普适性:只要翻译做的好,可以让两个没有关系的类一起工作<br>
                2.封装了复杂性,客户只需要知道Target对象就行了,至于源角色是什么,不需要了解<br>
                3.提供了复用性,可以让源角色在不同领域使用<br>
                4.灵活性好,因为唯一的关联就是适配器,所以如果不想要,删掉适配器不会带来什么影响.<br>
                总结:通过适配器实现对不同类的转接从而发挥新的作用,而不影响原本的功能<br>
                <img src="img/20240421/3_DesignMode/06_适配器模式.png" alt=""><br>

            </p>
            <section><h3>7.迭代模式</h3></section>
            <p>
                Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.<br>
                翻译:提供一种方法访问一个容器对象中各个元素,而又不需要暴露该对象的内部细节.<br>
                总结:一个几乎所有编程语言都实现了的模式,便利容器元素,了解即可<br>
                <img src="img/20240421/3_DesignMode/07_迭代模式.png" alt=""><br>
            </p>
        </article>
        <article id="4"><h2>4.Unity学习-HLSL学习</h2>
            <section><h3>1.信息的获取</h3></section>
            <p>
                1.切线空间<br>
                对于线性代数的理解不足,例子都列错了,怎么转换也没有弄清楚,所以需要等线性代数知识进步以后再来回头考虑<br>
                <img src="img/20240421/4_HLSL/01_求切线空间.png" alt=""><br>
                <img src="img/20240421/4_HLSL/02_线性空间求解失败.png" alt=""><br>
                <img src="img/20240421/4_HLSL/03_线性空间求解失败.png" alt=""><br>
                2.切线和副切线<br>
                坐标系的不同:OpenGL(右手系)和DX(左手系)<br>
                <img src="img/20240421/4_HLSL/04_坐标系.png" alt=""><br>
                <br>
                3.其他信息<br>
                <img src="img/20240421/4_HLSL/05_摄像机及屏幕信息.png" alt=""><br>
                <img src="img/20240421/4_HLSL/06_时间相关.png" alt=""><br>
            </p>
            <section><h3>2.倒圆角</h3></section>
            <p>
                1.算法逻辑<br>
                单纯的利用了UV的方式来剔除实现的圆角<br>
                <img src="img/20240421/4_HLSL/07_算法逻辑.png" alt=""><br>
                2.结果<br>
                会受到不均匀缩放的影响,所以还不算练习完成,等以后回头再考虑<br>
                <img src="img/20240421/4_HLSL/08_更光滑的圆角.gif" alt=""><br>
            </p>
            <section><h3>3.边缘光</h3></section>
            <p>
                1.目标效果
                从现实当中的菲涅尔效应Fresnel effect,摄影当中的轮廓光,抽象出来的效果边缘光RimLight
                <img src="img/20240421/4_HLSL/09_目标效果.png" alt=""><br>
                2.如何找到边缘
                <img src="img/20240421/4_HLSL/10_如何找到边缘.png" alt=""><br>
                3.点乘和方向的关系
                <img src="img/20240421/4_HLSL/11_点乘和方向的关系.png" alt=""><br>
            </p>
        </article>
        <article id="5"><h2>5.计算机学习-深度学习入门(Python)</h2>
            <section><h3>1.梯度和黑塞矩阵</h3></section>
            <p>
                求有表达式中包含其他导数的导数,通过反向传播可以跳过黑塞矩阵的创立.<br>
                梯度:多变量每个变量的导数<br>
                黑塞矩阵:多变量每两个变量的导数<br>
                <img src="img/20240421/5_DeepLearning/01_梯度和黑塞矩阵.png" alt=""><br>
            </p>
            <section><h3>2.雅可比矩阵</h3></section>
            <p>
                雅可比矩阵:输入和输出都是张量,对每个输入和每个输出分别求出导数的二维导数矩阵.<br>
                使用反向传播能够更快的计算雅可比矩阵来进行优化<br>
                <img src="img/20240421/5_DeepLearning/02_雅可比矩阵.png" alt=""><br>
            </p>
            <section><h3>3.reshape函数</h3></section>
            <p>
                reshape函数的实现,把变量数据更改形状<br>
                <img src="img/20240421/5_DeepLearning/03_reshape函数.png" alt=""><br>
            </p>
            <section><h3>4.sum函数</h3></section>
            <p>
                sum函数:张量求和<br>
                <img src="img/20240421/5_DeepLearning/04_sum函数.png" alt=""><br>
            </p>
            <section><h3>5.广播</h3></section>
            <p>
                broadcast_to函数和sum_to函数实现广播功能(不同形状之间的计算)<br>
                <img src="img/20240421/5_DeepLearning/05_广播.png" alt=""><br>
            </p>
        </article>
        <article id="6"><h2>6.计算机--HTML+CSS+JavaScript</h2>
            <section><h3>1.映射图</h3></section>
            <p>
                通过区域设置,让图片中不同区域可以当做超链接使用.<br>
                <img src="img/20240421/10_HTML/01_映射图.png" alt=""><br>
            </p>
            <section><h3>2.盒子模型</h3></section>
            <p>
                理解基础的HTML的盒子模型,和样式.<br>
                <img src="img/20240421/10_HTML/02_盒子模型.png" alt=""><br>
                <img src="img/20240421/10_HTML/03_使用开发者工具辅助学习CSS.png" alt=""><br>
            </p>
            <section><h3>3.侧边栏和导航栏</h3></section>
            <p>
                设置两边的侧边栏来辅助超链接导航.<br>
                <img src="img/20240421/10_HTML/04_侧边导航栏.png" alt=""><br>
            </p>
            <section><h3>4.侧边栏和导航栏样式</h3></section>
            <p>
                通过CSS修改侧边栏的样式<br>
                <img src="img/20240421/10_HTML/05_nav和aside样式.png" alt=""><br>
            </p>
            <section><h3>5.布局方式</h3></section>
            <p>
                尽可能的可以在不同设备下表现都OK<br>
                <img src="img/20240421/10_HTML/06_布局方式.png" alt=""><br>
            </p>
        </article>
        <article id="7"><h2>7.数学学习-MIT1801线性代数</h2>
            <section><h3>1.乘积法则证明</h3></section>
            <p>
                通过体积的示例来证明<br>
                <img src="img/20240421/6_Calculus/01_乘积法则证明.png" alt=""><br>               
            </p>
            <section><h3>2.商法则证明</h3></section>
            <p>
                通过导数的定义来推到的商法则<br>
                <img src="img/20240421/6_Calculus/02_商法则证明.png" alt=""><br>  
                利用商法则来证明其余常见三角函数<br> 
                <img src="img/20240421/6_Calculus/03_三角函数的证明过程.png" alt=""><br>
                <img src="img/20240421/6_Calculus/04_三角函数的证明.png" alt=""><br>
            </p>
            <section><h3>3.链式法则证明</h3></section>
            <p>
                <img src="img/20240421/6_Calculus/05_链式求导法则推导.png" alt=""><br>
            </p>
        </article>
        <article id="8"><h2>8.Unity学习_Unity3D游戏开发(C#)</h2>
            <section><h3>1.音频</h3></section>
            <p>
                音频资源<br>
                <img src="img/20240421/7_Unity3D/01_音频资源加载选项.png" alt=""><br>
                <img src="img/20240421/7_Unity3D/02_AudioSource.png" alt=""><br>
            </p>
            <section><h3>2.视频</h3></section>
            <p>
                视频资源<br>
                <img src="img/20240421/7_Unity3D/03_视频资源.png" alt=""><br>
                <img src="img/20240421/7_Unity3D/04_VideoPlayer.png" alt=""><br>
                <img src="img/20240421/7_Unity3D/05_渲染模式和视频自适应.png" alt=""><br>
                <img src="img/20240421/7_Unity3D/06_视频自适应模式.gif" alt=""><br>
                <img src="img/20240421/7_Unity3D/07_渲染模式.gif" alt=""><br>
            </p>
            <section><h3>3.其他</h3></section>
            <p>
                文件读取相关:XML,YAML,文件流<br>
                网络链接相关:Web链接和NetCode<br>
                SRP核心<br>
                <img src="img/20240421/7_Unity3D/08_核心代码.png" alt=""><br>
            </p>
        </article>
        <article id="9"><h2>9.计算机--图形学原理与实践(XAML)</h2>
            <section><h3>1.测试平台解析</h3></section>
            <p>
                <img src="img/20240421/8_XAML/01_完整XAML代码.png" alt=""><br>
                <img src="img/20240421/8_XAML/02_完整Csharp代码.png" alt=""><br>
            </p>
            <section><h3>2.第一个程序-Subdivide</h3></section>
            <p>
                <img src="img/20240421/8_XAML/03_Subdivide.gif" alt=""><br>                
            </p>
            <section><h3>3.视觉</h3></section>
            <p>
                在图形学"完美"到与真实无法区分之前,我们应更好地利用计算和显示资源,致力于生成视觉系统认可的真实,而不必在眼睛无法察觉(或几乎察觉不到)的细节差异上下功夫.<br> 
                视觉系统有强大的并行处理能力,一方面可容纳简陋或粗糙的数据,但另一方面却对数据非常敏感.眼睛对某些类型的瑕疵极为敏感,例如闪烁,高对比..<br> 
                在心理方面,如果最近某物体曾在你面前出现过,则面对一堆杂物时,你会很快注意到其中与它相似的物体.<br> 
                大脑的视觉皮层功能:已知的早期视觉(视觉信号处理的最初几步)可检测明度的尖锐对比.表面朝向和颜色的细小变化,以及空间频率(每厘米敏感变化的次数)<br> 
                总结就是我们擅长检测并留意"模式"的变化,对朝向,颜色或频率变化的检测是局部的(对相邻物体的颜色不同敏感.)<br> 
                人眼在黑暗区域更加敏感,亮度的变化比绝对值要更受关注,对物体的感知与光照环境几乎无关.<br> 
            </p>
        </article>
        <article id="10"><h2>10.美术学习-CG造型基础与创作</h2>
            <section><h3>1.美术学习路径</h3></section>
            <p>
                临摹->透视结构训练->线条训练循环<br>
                <img src="img/20240421/9_Artist/01_临摹练习.jpg" alt=""><br>
                <img src="img/20240421/9_Artist/02_透视结构练习.png" alt=""><br>
                <img src="img/20240421/9_Artist/03_透视练习.jpg" alt=""><br>
                <img src="img/20240421/9_Artist/04_排线.png" alt=""><br>
                <img src="img/20240421/9_Artist/05_透视练习.png" alt=""><br>
            </p>
        </article>
        <footer><a href="../../../../index.html">首页</a></footer>
        <script>
            document.write(document.lastModified);  // 打印上一次的修改时间
        </script>
    </body>
</html>
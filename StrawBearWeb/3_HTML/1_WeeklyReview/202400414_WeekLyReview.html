<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="StrawBear" content="记录一个学习者的过程">
        <title>20240401-14周总结</title>
        <link rel="stylesheet" href="../../1_CSS/basicStyle.css">
    </head>
    <body>
        <header><h1>对20240401-14这段时间的学习进行总结</h1></header>
        <nav></nav>
        <aside></aside>
        <article><h2>1.英语学习</h2>
            <section><h3>1.人称变化</h3></section>
            <div>
                当主语为第三人称单数或单数形式的名词或代词 he/she/it/your brother.....需要三单形式<br>
                be动词 is  am,助动词does,实意动词改三单形式,例如watch->watches<br>
            </div>
            <section><h3>2.时态变化</h3></section>
            <div>
                一般过去时:<br>
                1.be动词的变化根据人称和数来确定:<br>
                1.1当主语为第一人称单数I(我)或第三人称单数he/she/it(他/她/它)be动词变成was<br>
                I was at home yesterday.<br>
                翻译:我昨天在家<br>
                <br>
                1.2当主语为第一人称复数we(我们),第二人称单复数you(你/你们),第三人称复数they(他们/她们/它们)be动词变成were.<br>
                You were right about that.<br>
                翻译:关于那件事你说对了<br>
                <br>
                2.其他实意动词<br>
                当主语为第三人称单数或单数形式的名词或代词就需要动词改成三单形态加s或者es<br>
                例如:like->likes,have->has,watch->watches<br>
                <br>
                将来:<br>
                Dad can take us to school tomorrow.<br>
                翻译:爸爸明天可以带我们去学校<br>
                语法点:情态动词can+动词原型take表将来<br>
            </div>
            <section><h3>3.疑问句</h3></section>
            <div>
                普通疑问句:<br>
                1.动词是be动词,助动词或情态动词,将这些词提前到句首<br>
                例如:Were you in London last week?<br>
                翻译:你上周在伦敦吗?<br>
                <br>
                2.句中谓语动词为实义动词,需要借助do/does/did提前到句首,原本的动词使用原型.<br>
                三单形式用Does,其他都是do,如果是过去式那就统一都是did.<br>
                <br>
                特殊疑问句:<br>
                语法点:疑问副词,when(何时),where(哪里),why(为什么),How(如何)<br>
                用法:放在句首表示对特定问题的发问<br>
                Where will you live next year?<br>
                翻译:你明年会住在哪里?<br>
            </div>
            <section><h3>4.There be句型</h3></section>
            <div>
                语法点:There be句型,基本结构为“There be + 名词 + 地点/时间状语”，用于描述某处存在某物或某人<br>
                1.主谓一致<br>
                2.1主语为单数名词或不可数名词,be动词用is<br>
                There is some water in the cup.<br>
                翻译:被子里有一些水<br>
                <br>
                2.2主语为复数名词,be动词用are<br>
                There are many apples on the tree.<br>
                翻译:在树上有很多苹果.<br>
            </div>
            <section><h3>5.记忆</h3></section>
            <div>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/1_English/01_序数词_尊称_时间.png" alt=""><br>
            </div>
            <section><h3>6.其他</h3></section>
            <div>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/1_English/02_概念.png" alt=""><br>
            </div>
        </article>
        <article><h2>2.计算机图形学--计算机图形学原理(OpenGL)</h2>
            <section><h3>1.顶点处理</h3></section>
            <div>
                直接定义顶点坐标<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/2_ComputerGrapphics_OpenGL/01 定义顶点坐标.png" alt=""><br>
                <br>
                使用顶点索引来定义坐标<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/2_ComputerGrapphics_OpenGL/02_使用顶点索引坐标.png" alt=""><br>
            </div>
            <section><h3>2.阵列图元</h3></section>
            <div>
                <strong>1.概念</strong><br>
                概念:像素图(pixmap)<br>
                定义:一个彩色像素阵列称为一个像素图.<br>
                特性:阵列中每一个颜色值映射到一个或多个屏幕像素位置,像素阵列的参数通常包含指向颜色矩阵的指针,矩阵的大小,及其将要影响的屏幕区域.<br>
                <br>
                概念:位图bitmap/遮罩或掩膜mask<br>
                定义:简化矩阵,将矩阵中的每一像素位赋值为0或1,用以表示一个像素是否被赋予预定的颜色.<br>
                <br>

                <strong>2.实现</strong><br>
                2.1绘制位图<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/2_ComputerGrapphics_OpenGL/03_引用位图.png" alt=""><br>
                <br>
                2.2绘制像素图<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/2_ComputerGrapphics_OpenGL/04_绘制像素图准备.png" alt=""><br>
            </div>
            <section><h3>3.字符</h3></section>
            <div>
                <strong>1.概念</strong><br>
                概念:字样(typeface)-一组字符的完整设计风格<br>
                <br>
                概念:字体(font)-早先指的是一组按照特定尺寸和格式的模板字符样式(就像活字印刷的字块)<br>
                有衬线(serif)/无衬线(sans serif)<br>
                单一宽度(monospace)/比例宽度(proportional)<br>
                <br>
                概念:位图字体(bitmap font)/光栅字体(raster font) -使用矩形网格图案(位图)<br>
                概念:轮廓字体(outline font)/笔划字体(stroke font)-使用直线段和曲线段定义轮廓形状(矢量图)<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/2_ComputerGrapphics_OpenGL/05_位图和轮廓字体.png" alt=""><br>
                <br>
                概念:标记符号(markersymbol)/多点标记(polymarker)-一些特殊的标准字符,点,圆.十字等等<br>
                <strong>2.函数</strong><br>
                GLUT提供:<br>
                glutBitmapCharacter(font, character)可以显示GLUT位图字符<br>
                glutStrokeCharacter(font,character)可以显示轮廓字体<br>
            </div>
            <section><h3>4.显示表</h3></section>
            <div>
                把对象描述成一个命名的语句序列并存储起来既方便又高效.<br>
                在OpenGL当中使用称为显示表(display list)的结构来实现这一点.从而可以通过不同的显示操作来多次引用该表<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/2_ComputerGrapphics_OpenGL/06_显示表准备.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/2_ComputerGrapphics_OpenGL/07_显示表结果.png" alt=""><br>
            </div>
            <section><h3>5.GLUT窗口刷新函数</h3></section>
            <div>
                窗口刷新函数,可以拖动改变窗口尺寸了
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/2_ComputerGrapphics_OpenGL/08_窗口刷新函数.png" alt=""><br>
            </div>
            <section><h3>6.两个小示例</h3></section>
            <div>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/2_ComputerGrapphics_OpenGL/09_示例1折线图.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/2_ComputerGrapphics_OpenGL/10_示例2直方图.png" alt=""><br>
            </div>
        </article>
        <article><h2>3.计算机学习-设计模式(Java)</h2>
            <section><h3>9.抽象工厂模式</h3></section>
            <div>
                例子引入:<br>
                使用抽象工厂实现类工厂作为一个维度的划分<br>
                Human接口的抽象类作为另外一个维度的划分<br>
                从而实现了对产品的两个维度的划分.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/01_抽象工厂模式.png" alt=""><br>
                <br>
                正式定义:<br>
                Provide an interface for creating families of related or dependent objects without specifying their concrete classes.<br>
                翻译:为创建一组相关或互相依赖的对象提供一个接口,而且无须指定他们的具体类.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/02_抽象工厂定义.png" alt=""><br>
                <br>
                示例:两个产品,两个品牌工厂,对应了四个产品的工厂创建<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/03_抽象工厂总结.png" alt=""><br>
            </div>
            <section><h3>10.模板方法</h3></section>
            <div>
                例子引入:<br>
                模板方法通过将共同的部分给抽取出来,统一设置从而实现重复代码的复用,降低出现问题的概率<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/04_模板方法例子.png" alt=""><br>
                <br>
                正式定义:<br>
                定义:Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain seteps of an algorithm without changing the algorithm's structure.<br>
                翻译:定义一个操作中的算法框架,将一些步骤延迟到子类中,使得子类可以不改变一个算法的结构既可以重定义该算法的某些特定步骤.<br>
                抽象模板类:定义算法框架(模板方法),把步骤(基本方法)延迟到子类(具体模板类)实现.<br>
                代码处理:核心逻辑,一般不允许修改,使用final关键字<br>
                具体模板类:实现这些步骤方法(基本方法),不同的步骤方法让模板方法调用有不同的结果.<br>
                代码处理:这里的方法是不公开的,但是抽象模板类需要知道,所以不能是private而是protected.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/05_模板方法.png" alt=""><br>
                <br>
                扩展:<br>
                抽象类:在模板方法中设置一个新的钩子方法(返回布尔值的方法)来决定某个基本方法是否执行<br>
                实现类:可以通过覆盖钩子方法的返回值来控制抽象类中的模板方法的执行.当然也可以覆盖基本方法来控制基本方法的执行方式.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/06_模板方法扩展钩子方法.png" alt=""><br>
            </div>
            <section><h3>11.建造者模式</h3></section>
            <div>
                例子引入:<br>
                在抽象类当中准备了一个设置执行顺序的方法,<br>
                让子类可以设置不同的执行顺序,这个时候客户需要分别设置不同汽车实例的制造顺序<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/07_建造者模式引入1.png" alt=""><br>
                <br>
                把这个设置顺序的部分给抽离出来,让专门的建造者类负责设置,这个时候客户需要通过建造者来创建汽车实例<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/08_建造者模式引入2.png" alt=""><br>
                <br>
                再把一些预设的方案给到导演类,从而实现更加简单的调用,这个时候客户可以直接让导演类创造常见型号的汽车实例,而不关心细节了<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/09_建造者模式引入3.png" alt=""><br>
                <br>
                正式定义:<br>
                建造者模式BuIlder Pattern也叫作生成器模式 定义:Separate the construction of a complex object from its representation so that the same construction process can create different representations. 翻译:将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示. <br>
                Product产品类:通常包含模板方法和基本方法.<br>
                Builder抽象建造者:规范产品的组件,一般由子类实现<br>
                ConcreteBuilder具体建造者:实现抽象方法,组装并返回一个对象.<br>
                Director导演类:负责制备一些预设,方便调用.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/10_建造者模式正式定义.png" alt=""><br>        
            </div>
            <section><h3>12.代理模式</h3></section>
            <div>
                例子引入:<br>
                定义IGamePlayer接口类,确定游戏玩家需要执行的逻辑<br>
                实现接口的就是GamePlayer对象了<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/11_代理模式例子.png" alt=""><br>        
                <br>
                创建了一个新的GamePlayerProxy对象来负责委托操作给GamePlayer执行.,客户现在不需要直接操作游戏实例了<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/12_代理模式例子升级.png" alt=""><br>   
                <br>
                正式定义:<br>
                代理模式(Proxy Pattern) 定义:Provide a surrogate or placeholder for another object to control access to it. 翻译:为其他对象提供一种代理以控制对这个对象的访问. <br>
                ISubject主题接口,明确要实现哪些业务逻辑<br>
                实现对象RealSubject,实现了接口定义的方法<br>
                Proxy代理对象,代理对象代替指定的对象执行逻辑<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/13_代理模式正式定义.png" alt=""><br>   
                <br>
                扩展:<br>
                普通代理:客户只能访问代理角色,而不能访问真实角色.<br>
                GamePlayer实例对象,判断传入的对象不为空,才创建,也可以进行其他的判断限制创建条件<br>
                GamePlayerProxy实例对象,它负责了创建GamePlayer对象,所以客户需要关心的东西更少了.<br>
                客户对象需要知道的进一步减少,现在只需要知道给代理对象一个名字就可以创建游戏对象,然后代理可以执行登录,打怪,升级,在暗中这一切都被委托给了GamePlayer执行<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/14_普通代理.png" alt=""><br>   
                <br>
                强制代理:客户访问真实对象返回的是代理.必须通过代理进行访问.<br>
                IGamePlayer接口类要求增加一个可以获取代理的方法<br>
                GamePlayer游戏对象存储代理对象,实现接口的getProxy方法可以返回当前对象的代理对象.接口方法的实现,要求必须是通过代理.<br>
                代理对象就是把所有的执行都委托给代理了的游戏对象.唯一不同的就是代理本身没有代理所以返回自身.<br>
                客户端对象,现在我们必须通过游戏对象指定的代理才能访问游戏对象.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/15_强制代理.png" alt=""><br>   
                <br>
                个性代理:要求:在实现游戏对象功能基础上新增了代理的收费功能<br>
                新增了接口IProxy来约束代练的功能<br>
                代练对象GamePlayerProxy实现了这个新的计费功能,这个功能不是游戏对象有的,而是代练独有的<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/16_个性代理.png" alt=""><br>   
                <br>
                动态代理:要求:在实现阶段不关心谁代理,在运行阶段才指定代理哪一个对象.<br>
                代理对象GamePlayIH现在实现InvocationHandler接口,这个接口自动把委托的事情做了<br>
                动态代理对象直接绕过了创建代理这件事情,将主题这部分和代理给分开了,主题制作自己的逻辑,先完全不用考虑代理的事情,后期再由动态代理自动处理这个事情.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/17_动态代理.png" alt=""><br>   
                <br>
                标准动态代理:两条独立发展的路线,动态代理实现代理的职责,业务逻辑Subject实现相关的逻辑功能,二者之间没有必然的相互耦合关系.<br>
                主题对象Subject定义业务逻辑框架<br>
                真实主题对象RealSubject实现接口定义的业务逻辑<br>
                动态代理实现类MyInvocationHandler将所有通过动态代理实现的方法全部通过Invoke方法调用.<br>
                DynamciProxy泛型动态代理,把动态代理的实现部分给封装起来,方便其他地方调用产生动态代理<br>
                通知接口IAdvice,也是独立的,限制通知的方法<br>
                通知实现类BeforeAdvice,实现一个通知<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/18_标准动态代理.png" alt=""><br>   
                <br>
                简化动态代理:动态代理创建实现类<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/19_简化动态代理.png" alt=""><br>   
                <br>
                动态代理的调用逻辑是代理通过InvocationHandler自动实现空的Invoke方法,然后再把这个方法委托给Subject对象来实现.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/20_动态代理调用逻辑.png" alt=""><br>   
            </div>
            <section><h3>13.原型模式</h3></section>
            <div>
                例子引入:<br>
                AdvTemplate广告信模板类,设定通用的部分<br>
                Mail邮箱类,设定了一系列的属性,方便读取各种模板属性来创建邮件,<br>
                Client客户端类则通过Main调用模板类来修改一些不同的部分来创建不同的个性化邮件<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/21_原型模式例子.png" alt=""><br>   
                <br>
                为了可以执行多线程,Mail类实现了克隆接口,然后实现了对应的方法,实现不再实例引用,从而避免互相影响<br>
                Client客户端类每次调用克隆方法创建新的对象,这样就可以不怕多线程了<br>
                这种不通过new关键字来产生一个新的对象,而是通过对象复制来实现的模式就叫做原型模式<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/22_原型模式例子2.png" alt=""><br>   
                <br>
                正式定义:<br>
                Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.<br>
                翻译:用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象<br>
                Java当中的Cloneable只是一个标识接口,里面没有任何方法,单纯是一个标记,JVM只会对具有这个标记的对象进行拷贝,实际上我们覆盖的事所有类的祖宗Object类的clone方法<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/3_TheZenOfDesignMode_Java/23_原型模式.png" alt=""><br>   
                <br>
                注意事项:<br>
                1.构造函数不会被执行<br>
                原理是因为clone方法是直接从堆内存复制一份二进制重新分配一个内存块,所以自然就不会执行构造函数了<br>
                2.浅拷贝和深拷贝<br>
                clone对于内部的数组,引用对象等都不拷贝,只是拷贝地址,这种拷贝就叫做浅拷贝.(成员变量且是可变的引用对象)<br>
                深拷贝则是对于所有变量的完全拷贝,需要在clone方法里面独立实现,例如thing.arrayList=(ArrayList泛型String)this.arrayList.clone();这样就会进入到数组,再克隆,而不是克隆浅层的引用.<br>
                3.final和clone<br>
                定义了final就不允许动内存中的对象了,这自然是无法克隆的.<br>
            </div>
        </article>
        <article><h2>4.Unity学习-HLSL学习</h2>
            <section><h3>1.MVP过程</h3></section>
            <div>
                模型空间M->世界空间W->观察空间V->裁切空间P<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/01_MVP过程.png" alt=""><br>
                <br>
                Unity提供的变换矩阵<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/02_Unity提供的变换矩阵.png" alt=""><br>
            </div>
            <section><h3>2.渲染队列</h3></section>
            <div>
                Background和Overlay一个最先绘制,一个最后绘制.<br>
                Geometry和Alpha Test都是按照从近到远绘制,这叫做反向画家算法,先绘制近的物体,再绘制远处不被遮挡的对象.<br>
                Transparent按照从远到近的顺序绘制,这叫做画家算法,从最远的物体往最近的绘制,前面的物体会覆盖融合(混合)后面的物体.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/03 Unity默认渲染队列值.png" alt=""><br>
            </div>
            <section><h3>3.深度测试</h3></section>
            <div>
                深度测试,深度写入,深度裁切与Early-z<br>
                根据遮挡关系,距离近的物体应该被覆盖在距离远的物体上,如果是规则的,不互相穿插的物体,只需要根据物体的中心点排序即可.<br>
                但是通常模型都是复杂的,所以以一个整体进行排序就不合适了,因此将度量的单位从模型升级成了片元,根据片元距离摄像机的距离来判断渲染顺序,这个概念就是深度depth(片元距离摄像机的距离)<br>
                在我们将模型转换到裁切空间之后,为了提高计算速度,减少对于不同设备的考虑,GPU会进行归一化操作,将裁切空间变化到一个标准立方体当中,这个空间称为归一化设备坐标系Normalized Device Coordinate,NDC<br>
                深度缓冲区:这个时候我们只需要对比当前片元与上一个片元的深度值,就可以知道是否可见,所以需要一个存储深度信息的池,这个池就是深度缓冲区z-buffer.<br>
                深度测试:若当前片元的深度值小于池中的深度值,说明离摄像机更近,所以应该渲染当前这个片元.否则就丢弃当前片元.这个过程就叫做深度测试Z-Test<br>
                深度写入:这个将新的深度值写入深度缓冲区的过程称之为深度写入Z-Write<br>
                深度裁切:通过深度测试对片元进行选取或丢弃的过程称之为深度裁切.Z-Clip<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/04_深度测试过程.png" alt=""><br>
                <br>
                相关设置值<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/05_深度测试相关取值.png" alt=""><br>
                <br>
                ColorMask的设置<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/06_ColorMask取值.png" alt=""><br>
            </div>
            <section><h3>4.模板测试</h3></section>
            <div>
                模板值相关操作可控部分<br>
                1.模板值设定,读取和写入遮罩<br>
                2.比较方式<br>
                3.缓冲区模板值的处理<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/07_模板值相关操作.png" alt=""><br>
                <br>
                比较操作<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/08_比较操作和模板值操作参数.png" alt=""><br>
            </div>
            <section><h3>5.材质面板</h3></section>
            <div>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/09_小标签及功能.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/10_UI优化功能.png" alt=""><br>               
            </div>
            <section><h3>6.顶点上的其他信息</h3></section>
            <div>
                1.法线<br> 
                概念:平滑着色(Smooth Shading),顶点法线为其连接的所有平面法线的加权平均值<br> 
                概念:平面着色(Flat Shading):顶点的发现为其所连接平面的法线.<br> 
                对应于DCC软件中设置的软硬边或者光滑组<br> 
                1.光滑组:同一光滑组的顶点是按照平滑着色的,不同的按照平面着色.<br> 
                2.软硬边:硬边表示需要断开是平面着色,软边表示需要光滑是平滑着色<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/11_对比.png" alt=""><br>               
                <br> 
                不均匀缩放的危害<br> 
                当我们对物体进行不均匀缩放,会带来法线位置的偏移,为了解决这个问题,我们需要反向缩放还原<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/12_法线单轴缩放.png" alt=""><br>               
                <br> 
                2.顶点色:DCC软件中指定好的一个值,可以通过COLOR语义读取.<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/4_UnityShader_HLSL/13_顶点色.png" alt=""><br>               
            </div>
        </article>
        <article><h2>5.计算机学习-深度学习入门(Python)</h2>
            <section><h3>1.优化方法</h3></section>
            <div>
                1.泰勒展开<br> 
                Sin函数实现<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/01_Sin函数的视线.png" alt=""><br>               
                <br> 
                泰勒展开理论<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/02_泰勒展开理论.png" alt=""><br>               
                <br> 
                泰勒展开实现,逼近Sin测试<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/03_使用麦克劳林级数来近似sinx的值.png" alt=""><br> 
                <br>
                2.梯度下降<br>
                Rosenbrock函数实现<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/04_Rosenbrock实现.png" alt=""><br> 
                <br>
                形状复杂的函数,其最大值可能不在梯度指示的方向上,不过从局部来看,梯度表示函数的输出值最大的方向.重复向梯度方向移动一定距离,然后再次求梯度的过程,可以帮助我们逐渐接近目标位置(最大值或最小值),这就是梯度算法<br>
                给一个好的初始值,再使用梯度算法能帮我们高效的找到目标值.<br>
                我们的目标是找到香蕉函数的最小值,通过梯度下降算法我们就找到了最小值<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/05_梯度下降算法.png" alt=""><br> 
                <br>
                3.牛顿迭代法<br>
                牛顿迭代法理论<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/06_牛顿迭代法理论.png" alt=""><br> 
                <br>
                效率:梯度下降只利用到了一阶导数信息来优化,而牛顿法利用了一阶和二阶导数信息来优化.仅仅7次就收敛了<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/07_牛顿迭代法实现.png" alt=""><br> 
            </div>
            <section><h3>2.修改Dezero支持高阶导的计算</h3></section>
            <div>
                原始状态:<br> 
                执行Y=sin(x)的时候,SIn类的forwaard方法执行,计算图被创建,Varibale的实例变量data被赋值.<br> 
                执行反向传播的时候,Sin类的backawrd方法被调用,Variable的示例变量grad被赋值.<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/08_sin函数的正向反向传播.png" alt=""><br> 
                <br> 
                创建反向传播的计算图的方法<br> 
                连接是在Variable变量进行正向传播的过程中创建的.这意味着如果我们在函数的backward方法中使用Variable实例替代ndarry实例就业会创建计算连接,为此我们需要将导数(梯度)保存为Variable实例.<br> 
                图中展示了Variable的变化<br> 
                左图是以前的,Variable类的grad引用ndarry实例对象.<br> 
                有图让grad变成导数Variable类gx的引用.<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/09_实现高阶导修改.jpg" alt=""><br> 
                <br> 
                从引用转到对变量的引用<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/10_高阶导实现.png" alt=""><br> 
                <br> 
                控制反向传播<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/11_控制是否开启反向传播.png" alt=""><br> 
                <br> 
                实现自动计算的牛顿迭代法<br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/12_自动计算的牛顿迭代法.png" alt=""><br> 
            </div>
            <section><h3>3.支持高阶导的函数实现</h3></section>
            <div>   
                Sin和Cos函数的实现-可以计算二阶导的<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/13_Sin和Cos函数的实现.png" alt=""><br> 
                <br>
                Tanh函数的实现<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/5_DeepLearning_Python/14_tanh函数的实现.png" alt=""><br> 
            </div>
        </article>
        <article><h2>6.计算机--HTML+CSS+JavaScript</h2>
            <section><h3>6.列表和表格</h3></section>
            <div>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/10_HTML_CSS_JS/01_列表和表格.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/10_HTML_CSS_JS/02_表格控制.png" alt=""><br> 
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/10_HTML_CSS_JS/03_Columns.png" alt=""><br> 
            </div>
            <section><h3>7.内部和外部链接</h3></section>
            <div>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/10_HTML_CSS_JS/04_使用内部和外部链接.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/10_HTML_CSS_JS/05_使用内部和外部链接2.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/10_HTML_CSS_JS/06_使用CSS设置样式.png" alt=""><br>                
            </div>
            <section><h3>8.颜色,图像和多媒体</h3></section>
            <div>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/10_HTML_CSS_JS/07_颜色的选择.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/10_HTML_CSS_JS/08_图像链接.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/10_HTML_CSS_JS/09_图像映射.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/10_HTML_CSS_JS/10_链接和嵌入多媒体.png" alt=""><br>            
            </div>
        </article>
        <article><h2>7.数学学习-MIT1801线性代数</h2>
            <section><h3>1.Second derivatives and higher:二阶导和更高阶导数</h3></section>
            <div>
                二阶导的凹性<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/6_MIT1801_Calculus/01_二阶导.png" alt=""><br>            
                <br>
                现实:位置速度加速度<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/6_MIT1801_Calculus/02_位置速度和加速度.png" alt=""><br>                   
            </div>
            <section><h3>2.Trigonometric functions:三角函数</h3></section>
            <div>
                有效数字<br>
                定义:有效数字是那些具有精确意义的数字的个数<br>
                <br>
                有效的示例:<br>
                所有的非零数字都是有效的,例如1235有4位有效数字<br>
                在非零数字间的0是有效的,例如101有3位有效数字<br>
                小数部分的0是有效的,例如32.000有5位有效数字<br>
                <br>
                无效的示例<br>
                非小数的尾缀的0是无效的,例如5400有2位有效数字<br>
                小数数字前面的零是无效的,例如0.00003只有1位有效数字<br>
                如果计算结果的精度超出当前值的精度,那么超出的部分是不重要的,例如0.25*0.50,那么结果的0.125,这个5是不重要的.<br>
                <br>
                sin和cos的导数<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/6_MIT1801_Calculus/03_正弦和余弦的导数.png" alt=""><br>                   
            </div>
            <section><h3>3.Linear approximation:线性近似</h3></section>
            <div>
                线性近似:<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/6_MIT1801_Calculus/04_线性近似.png" alt=""><br>                   
            </div>
            <section><h3>4.Product rule:乘积法则</h3></section>
            <div>
                乘积法则:<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/6_MIT1801_Calculus/05_乘积法则.png" alt=""><br>                   
            </div>
        </article>
        <article><h2>8.Unity学习_Unity3D游戏开发(C#)</h2>
            <section><h3>7.3 动画系统</h3></section>
            <div>
                7.3.7 动画混合<br>
                代码逻辑:通过将两个动画关联到混合Playable中,然后统一交给Playable播放,只需要在Update()中通过调用SetInputWeight就可以设置每个动画混合的权重实现混合动画了.<br>
                <br>
                7.3.8 老版动画<br>
                使用Animation配合老版本动画文件<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/01_Animaiton.gif" alt=""><br>
                <br>
                7.3.9 Simple Animation组件<br>
                使用SimpleAnimation组件适配新老版动画<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/02_SimpleAnimaiton.gif" alt=""><br>
                <br>
                .length获取片段时长<br>
                .time设置播放时间<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/03_进度控制.gif" alt=""><br>
                <br>
                通过CrossFade过渡动画,Blend混合动画,GetState设置权重,Rewind重新播放,speed属性设置播放速度<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/04_过渡.gif" alt=""><br>
                <br>
                7.3.12 Playable组件<br>
                导入Assert文件夹,通过主菜单栏Windows_PlayableGraph Visualizer打开,当运行的时候会自动读取场景中的PlayableGraph实例<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/05_VG.png" alt=""><br>
                <br>
                音频混合,和动画是一样的逻辑,创建混合器,把资源链接到混合器,设置混合比率,链接到输出,播放.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/06_混合音频和其他.png" alt=""><br>
                <br>
                7.3.14 模型换装<br>
                三种模型的跟换<br>
                1.换皮肤,直接换材质球就可以了<br>
                2.换网格信息(没有动画),直接换Mesh就可以了<br>
                3.蒙皮骨骼(带动画),需要换骨骼,根结点,材质球,网格<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/07_模型换装.gif" alt=""><br>
            </div>
            <section><h3>7.4 3D物理系统</h3></section>
            <div>
                7.4.1 角色控制器<br>
                7.4.2 碰撞体<br>
                7.4.3 Rigidbody组件<br>
                7.4.4 碰撞事件<br>
                7.4.5 布娃娃系统<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/08_布娃娃系统.gif" alt=""><br>
                7.4.6 布料系统<br>
                7.4.7 其他<br>
            </div>
            <section><h3>7.5 输入系统</h3></section>
            <div>
                7.5.1 实体输入事件<br>
                7.5.2 虚拟输入事件<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/09_鼠标移动.gif" alt=""><br>
                <br>
                7.5.3 鼠标位置<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/10_控制UI结果.gif" alt=""><br>
                <br>
                7.5.4 点选模型<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/11_射线选择事件.gif" alt=""><br>
                <br>
                7.5.5 通过点击控制移动<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/12_移动到指定位置.gif" alt=""><br>
                <br>
                7.5.6 射线<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/13_射线碰撞.gif" alt=""><br>
            </div>
            <section><h3>7.6 Transform组件</h3></section>
            <div>
                7.6.1 控制角色移动<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/14_人物移动.gif" alt=""><br>
                <br>
                7.6.2 摄像机跟随<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/15_摄像机跟随.gif" alt=""><br>
                <br>
                7.6.3 插值移动<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/16_平滑差值.gif" alt=""><br>
                <br>
                7.6.4 约束条件<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/17_约束.gif" alt=""><br>
            </div>
            <section><h3>9.数据持久化</h3></section>
            <div>
                9.1 Excel<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/18_读取Excel.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/19_写内容到Excel.png" alt=""><br>
                <br>
                9.2 SQLite<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/20_跨平台读取SQlite数据库.png" alt=""><br>
                <br>
                9.3 JSON<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/21_JSON读取.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/22_Newton读取JSON.png" alt=""><br>
                <br>
                9.4 文件的读取和写入<br>
                PlayerPrefs存储路径<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/23_PlayerPrefs存储路径.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/7_Unity3DGameDevelopment_Csharp/24_File文本读取和写入.png" alt=""><br>
            </div>
        </article>
        <article><h2>9.计算机--图形学原理与实践(XAML)</h2>
            <section><h3>1.动态控制</h3></section>
            <div>
                WPF动画控制<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/8_ComputerGraphicsTheoryAndPractice_XAML/01_WPF动态控制.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/8_ComputerGraphicsTheoryAndPractice_XAML/02_结果.gif" alt=""><br>
            </div>
            <section><h3>2.丟勒的木刻画</h3></section>
            <div>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/8_ComputerGraphicsTheoryAndPractice_XAML/03_丟勒木刻画.png" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/8_ComputerGraphicsTheoryAndPractice_XAML/04_丟勒木刻画算法实现.png" alt=""><br>                
            </div>
            <section><h3>3.2D测试平台</h3></section>
            <div>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/8_ComputerGraphicsTheoryAndPractice_XAML/05_测试平台目标.gif" alt=""><br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/8_ComputerGraphicsTheoryAndPractice_XAML/06_测试平台结构.png" alt=""><br>
            </div>
        </article>
        <article><h2>10.美术学习-CG造型基础与创作</h2>
            <section><h3>1.临摹问题</h3></section>
            <div>
                临摹的作用<br>
                1.建立现实的心理预期:首先需要能顺利完成临摹,后面创作才会不受到限制<br>
                2.明确临摹的目的:临摹主要用于养成整体观察和对比的习惯,掌握打型和选色的技能.<br>
                3.临摹与创作尝试并行:学习绘画的本质是想要表达自己的感觉,而不是临摹机器,所以临摹和创作并行.<br>
            </div>
            <section><h3>2.结构概括</h3></section>
            <div>
                结构概括的意义<br>
                结构概括可以被应用在对物体的观察上.在框架结构模式下,我们更容易把握物体的形态特征,也更容易看出物体的形成规律.<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/01_结构概括.png" alt=""><br>
                <br>
                1.基本几何体,球体,圆柱,方块,圆锥及其延伸体<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/02_基本几何体.png" alt=""><br>
                <br>
                2.关键转折:影响线条整体趋势,转折较为剧烈的点(用数学的说法就是切线方向变化剧烈的点,那就是一阶导数变化大的点,转折点)<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/03_关键转折点.png" alt=""><br>
                <br>
                3.典型表面:概括物体表面的趋势<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/04_典型表面.jpg" alt=""><br>
            </div>
            <section><h3>3.透视</h3></section>
            <div>
                透视是人类普遍的视觉经验,我们需要通过正确的透视表达,使创作者和观众对作品的结构认知趋向一致<br>
                直线的透视投影还是直线(透视后依然是直线),但对于包含投影中心点的直线束,其透视投影无定义(汇聚成的一个点,也就是灭点).<br>
                <br>
                1.术语<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/05_透视术语.png" alt=""><br>
                <br>
                2.透视类型<br>
                一点透视<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/06_一点透视.png" alt=""><br>
                <br>
                二点透视<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/07_二点透视.png" alt=""><br>
                <br>
                三点透视<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/08_三点透视.png" alt=""><br>
                <br>
                五点透视<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/09_五点透视.png" alt=""><br>
                <br>
                3.透视盒子与点定位<br>
                使用一个方块进行包裹,得到透视关系,然后绘制变形后的原来对象<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/10_方块包裹.png" alt=""><br>
                <br>
                4.绘制流程总结<br>
                A.按照你所期望的观察角度画出视平线<br>
                B.确定方块中离你最近的那条竖边,按你期望的视角估算两个消失点的位置,画出离你最近的四条平行于地面的边,这些边的延长线汇聚于两边的消失点上.<br>
                C.目测估算要绘制方块的长.宽,高比例,在四条已经画出的边上做标记,然后连接他们,(注意上面也是有一个消失点的)<br>
                D.画出方块远侧的四条平行于地面的边,它们的延长线应该也聚集于两边的消失点上<br>
                E.连接方块远侧四条边交叉形成的两个交点<br>
                F.去除多余的线,绘制完成<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/11_绘制流程.png" alt=""><br>
                <br>
                4.绘制练习<br>
                <img src="../../3_HTML/1_WeeklyReview/img/20240414/9_Artist/12_第一次绘制结果.png" alt=""><br>
            </div>
        </article>
        <footer><a href="../../../index.html">首页</a></footer>
        <script>
            document.write(document.lastModified);  // 打印上一次的修改时间
        </script>
    </body>
</html>
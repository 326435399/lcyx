<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>计算机图形学入门_3D渲染指南_第二章_简单光线追踪</title>
</head>
<body>
    <center>
        <canvas id="canvas" width=600 height=600 style="border: 1px grey solid"></canvas><br>
        <table>
            <tr bgcolor="#e0e0e0">
                <td><b>Shadow ray start</b></td>
                <td>
                    <input type="radio" name="shadow-ray-start" onClick="SetShadowEpsilon(0);">Zero</input><br>
                    <input type="radio" name="shadow-ray-start" onClick="SetShadowEpsilon(0.001);" checked>Epsilon</input>
                </td>
            </tr>
        </table>
    </center>

        <script>
            // 画布的访问
            var canvas = document.getElementById("canvas");  // 看起来是获取canvas这个id的元素的引用
            var canvas_context = canvas.getContext("2d");  // 这里是获取了画布的引用,加下来可以绘制了
            // getImageData获取指定区域的像素(x,y,矩形宽度,矩形高度)xy决定了位置,宽度高度决定了矩形像素大小,这里获取整个画布
            var canvas_buffer = canvas_context.getImageData(0, 0, canvas.width, canvas.height); 

            var PutPixel = function(x, y, color)  // 在屏幕上绘制像素的函数          
            {
                x = canvas.width/2 + x;  // 因为左上角是(0,0)所以想要转移到我们习惯的中间是(0,0)
                y = canvas.height/2 - y;  // 同样是为了转移到中间作为0,0,第一章介绍的内容

                // 绘制位置不正确的情况,x<0,y<0,或者大于高度宽度,都表示像素在画布的外面了
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height)
                {
                    return;
                }

                var offset = 4*x + canvas_buffer.width * 4 *y;  // 因为每一个像素的Data都有RGBA四个属性
                // 所以左上角(0,0)像素的索引就是 4*0 + 画布宽度*4*y(一行需要的索引)=0,所以RGBA的索引是0,1,2,3
                // 第二行的第一个像素(0,1)像素的索引是4*0 + 600*4*1 = 2400,所以RGBA的索引是2400,2401,2402,2403
                canvas_buffer.data[offset++] = color[0];  // 通过自加操作符,实现了索引的自动增加
                canvas_buffer.data[offset++] = color[1];
                canvas_buffer.data[offset++] = color[2];
                canvas_buffer.data[offset++] = 255; // Alpha = 255 (full opacity)
            }

            var UpdateCanvas = function()  // 更新像素的函数--原理不知道
            {
                canvas_context.putImageData(canvas_buffer, 0, 0);  // 把画布放回去左上角
            }
            
            var ClearAll = function()  // chapter4_1新增
            {
                canvas.width = canvas.width;  // 没有看懂..
            }

            // 计算方法准备区

            var EPSILON = 0.001;  // chapter新增,顶点的些微偏移,以确保自身不会投射阴影

            var DotProduct = function(v1, v2)  // 线性代数点积计算--原理是分别相乘相加,得到的是一个标量
            {
                return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];  
            }

            var Subtract = function(v1, v2)  // 线性代数两个向量相减,得到的是分量分别相减的向量
            {
            return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
            }

            // chapter3新增处理函数四个,计算矢量长度,计算标量矢量相乘,计算矢量相加,钳值结果到0-255
            var Length = function(vec)  // 计算任意维度矢量的模,这里采用的是矢量和自己点积开根号就是模长,还有一种思路是用各个分量的平方和开根号,一样的想法
            {
                return Math.sqrt(DotProduct(vec, vec));
            }

            var Multiply = function(k, vec)  // 计算三维矢量的标量k乘以矢量k*V(x,y,z) = kx,ky,kz
            {
                return [k*vec[0], k*vec[1], k*vec[2]];
            }

            var Add = function(vec1, vec2)  // 计算两个三维矢量相加,A(x,y,z) + B(x1,y1,z1) = x+x1, y+y1, z+z1
            {
                return [vec1[0] + vec2[0], vec1[1]+ vec2[1], vec1[2]+ vec2[2]];
            }

            var Clamp = function(vec)  // 进行三维矢量的钳值,如果值小于0,钳值到0,大于255钳值到255
            {
                return [Math.min(255, Math.max(0, vec[0])),Math.min(255, Math.max(0, vec[1])),Math.min(255, Math.max(0, vec[2]))];
            }

            var ReflectRay = function(v1, v2) // chapter4-2新增,输入向量v1和v2,V1是入射向量,v2是法线向量,返回他们的反射向量
            {
                return Subtract(Multiply(2*DotProduct(v1, v2), v2), v1);
            }

            // 场景对象设置  // chapter3_2添加了specular属性
            var Sphere = function(center, radius, color, specular, reflective)  // 定义了一个球体类,有三个属性,中心点,半径和颜色
            {
                this.center = center;  // 定义当前类的center属性就等于我们输入的center
                this.radius = radius;  // 同理
                this.color = color;  // 同理
                this.specular = specular;  // chapter3_2添加的表示镜面反射指数(光泽度!)
                this.reflective = reflective;  // chapter4-2新增,添加反射系数
            }

            // chapter3新增灯光类
            var Light = function(ltype, intensity, position)  // ltype是灯光类型,intensity是强度,position是位置
            {
                this.ltype = ltype;
                this.intensity = intensity;
                this.position = position;
            }

            // chapter3新增,定义了三个常量好像
            Light.AMBIENT = 0;
            Light.POINT = 1;
            Light.DIRECTIONAL = 2;

            //  定义基本场景
            var viewport_size = 1;  // 定义视口尺寸为1,所以Vw视口宽度和Vh视口高度都为1
            var projection_plane_z = 1;  // 定义视口到画布距离为1
            var camera_position = [0, 0, 0];  // 定义摄像机位置为原点
            var background_color = [0, 0, 0];  // 定义变量background_color=黑色
            // 接下来创建了三个球类实例  chapter3新增一个大球,chapter4-2新增了最后一个参数作为reflection值
            var spheres = [new Sphere([0, -1, 3], 1, [255, 0, 0], 500, 0.2),new Sphere([2, 0, 4], 1, [0, 0, 255], 500, 0.4),new Sphere([-2, 0, 4], 1, [0, 255, 0], 10, 0.3), new Sphere([0, -5001, 0], 5000, [255, 255, 0], 1000, 0.5)]; 

            // chapter3新增灯光,Ambient灯是环境灯,不需要设定位置
            var lights = [new Light(Light.AMBIENT, 0.2, [1,1,1]), new Light(Light.POINT, 0.6, [2, 1, 0]), new Light(Light.DIRECTIONAL, 0.2, [1, 4, 4])];

            var recursion_depth = 3;  // chapter4-2新增,限定递归调用的次数,这个值代表反射跟踪的次数


            // 传入任何参数列表,返回对应计算的视口位置信息
            var CanvasToViewport = function(p2d)  
            {
                // 返回第一个参数是 第一个输入x*视口宽度/画布宽度,得到的视口x位置,同理第二个返回是y位置,第三个是视口和画布距离z
                return [p2d[0] * viewport_size / canvas.width, p2d[1] * viewport_size / canvas.height, projection_plane_z]; 
            }

            // 定义函数来计算球体和射线的交点origin是射线原点
            var IntersectRaySphere = function(origin, direction, sphere)
            // 也就是摄像机位置(0,0,0),direction是射线的方向(origin为0,0,0)也就是对象的点,其实应该是direction-origin,sphere是球体实例
            {
                var oc = Subtract(origin, sphere.center);  // 原点减去球体=球体到原点的矢量CO

                var k1 = DotProduct(direction, direction);  // 计算的是二元方程的a值,a=D·D
                var k2 = 2 * DotProduct(oc, direction);  // 计算的是二元方程b值,b=2(CO·D)
                var k3 = DotProduct(oc, oc) - sphere.radius*sphere.radius;  // 计算的是二元方程c值,c=CO·CO

                var discriminant = k2*k2 - 4*k1*k3;  // 判别式b²-4ac
                if (discriminant < 0)   // 小于0,无解
                {
                    return [Infinity, Infinity];  // 返回两个无穷大,会直接跳过t1和t2的绘制
                }

                var t1 = (-k2 + Math.sqrt(discriminant)) / (2*k1);  // 返回求根公式 -b±根号(b²-4ac)/2a的两个解
                var t2 = (-k2 - Math.sqrt(discriminant)) / (2*k1);
                return [t1, t2];
            }

            // chapter3_1新增计算光照强度函数
            var ComputeLighting = function(point, normal, view, specular)  // point是物体表面的点,normal是物体表面法线
            {
                var intensity = 0;  // 用来存储计算的全光光加起来的结果
                var length_n = Length(normal);  // 规格化法线N
                var length_v = Length(view);  // chapter3_2新增,规格化view

                for (var i = 0; i < lights.length; i++)  // 遍历所有的灯光
                {
                    var light = lights[i];  // 获取对应灯对象的引用
                    if (light.ltype == Light.AMBIENT)  // 如果是环境光
                    {
                        intensity += light.intensity;  // 所有对象都直接加上环境光强度即可
                    }
                    else
                    {
                        // 对不同灯光的灯光方向进行处理
                        var vec_l;  // 点光和平行光的光照方向是不同的计算方式
                        var t_max;  // 因为对于平行光和点光的允许寻找的距离也是不一样的
                        if (light.ltype == Light.POINT)  // 如果是点光源
                        {
                            vec_l = Subtract(light.position, point);  // 点光源的光照方向等于灯光发射点-物体表面的点,等于表面到灯光发射点的向量
                            t_max = 1.0;  // 点光源找到灯光发射点已经足够了
                        }
                        else  // 剩下的就是平行光源了
                        {
                            vec_l = light.position;  // 平行光的方向就是灯光的发射点矢量(也就是世界坐标原点指向灯光发射点)
                            t_max = Infinity;  // 平行光的发射源是无限远,所以也要这样算
                        }

                        var blocker = ClosestIntersection(point, vec_l, EPSILON, t_max);  // 计算光线是否有被物体遮挡
                        if (blocker) 
                        {
                            continue;  // 当次循环就被结束了,所以不会再计算后面的光照了,表示全部被阴影遮蔽
                        }

                        // 计算漫反射
                        var n_dot_l = DotProduct(normal, vec_l);  // 计算的法线方向N和灯光方向L的点积,也就是夹角余弦值cosθ
                        if (n_dot_l > 0)
                        {
                            intensity += light.intensity * n_dot_l/(length_n * Length(vec_l));  
                            // 强度值 = 灯光强度值 * 夹角余弦值/(N的模*L的模)结果就是单位光照贡献,后面有化简版本,把vec_l规格化,结果就是直接光照强度*n_dot_l
                        }
                        
                        // chapter3_2新增,计算镜面反射部分
                        if (specular != -1)  // 光泽度不能是负的
                        {
                            // var vec_r = Subtract(Multiply(2.0*DotProduct(normal, vec_l),normal), vec_l);  // 公式R=2N(N·L) - L
                            var vec_r = ReflectRay(vec_l, normal);  // chapter4-2调用提取出去的公式重构了这一部分计算反射向量的方式
                            var r_dot_v = DotProduct(vec_r, view); // 计算R·V
                            if (r_dot_v > 0)  // R·V大于0表示他们之间的夹角在0-90°之间,当等于0的时候夹角为90°,当小于0,就是钝角,这种情况我们看不到
                            {
                                intensity += light.intensity * Math.pow(r_dot_v/(Length(vec_r) * length_v), specular);
                                // 公式 反射灯光强度Is = 灯光强度 * [R·V/(|R||V|)]的光泽度S次幂
                            }
                        }
                    }
                }
                return intensity;  // 返回计算出来的完整光照强度
            }

            // 重写了函数
            var ClosestIntersection = function(origin, direction, min_t, max_t)  // origin就是摄像机原点,direction是指向物体表面方向,min_t和max_t指定了检测范围 
            {
                var closest_t = Infinity;  // 首先定义最接近的t为无穷大
                var closest_sphere = null;  // 定义默认没有找到能遮蔽的对象(我们就只有球体对象)
                
                for (var i = 0; i < spheres.length; i++)  // 遍历所有的球
                {
                    var ts = IntersectRaySphere(origin, direction, spheres[i]);  // 寻找射线和球的交点,只是这次初始点不太一样,是物体表面的点P
                    if (ts[0] < closest_t && min_t < ts[0] && ts[0] < max_t)  // 如果在限制的检测范围内计算的t值小于最接近的t,也就是有值 
                    {
                    closest_t = ts[0];  // 记录这个最近的t值
                    closest_sphere = spheres[i];  // 记录这个球体为找到的球体
                    }
                    if (ts[1] < closest_t && min_t < ts[1] && ts[1] < max_t)  // 如果第二个t值也找到了,那就表示有两个解了 
                    {
                    closest_t = ts[1];  // 把这个t作为最近的值
                    closest_sphere = spheres[i];  // 记录这个球体
                    }
                }
                
                if (closest_sphere)  // 如果有找到球体
                {
                    return [closest_sphere, closest_t];  // 返回这个球体,和最近球体的t值
                }
                return null;  // 找不到球体,直接返回null
            }

            // 射线跟踪,返回最接近视口对应的颜色,输入射线原点,物体表面的点,最小距离,最大距离
            var TraceRay = function(origin, direction, min_t, max_t, depth)
            {
                var intersection = ClosestIntersection(origin, direction, min_t, max_t);  // 调用函数计算是否有相交
                if (!intersection)  // 找不到球体
                {
                    return background_color;  // 直接返回我们设定的背景色
                }

                var closest_sphere = intersection[0];
                var closest_t = intersection[1];

                var point = Add(origin, Multiply(closest_t, direction));  
                // 这里就是射线方程,O+tD,O是射线发射点,t是我们找到的物体表面的t,D是射线方向,这里得到了这个离相机最近的射线交点的矢量,也就是物体表面P的矢量
                var normal = Subtract(point, closest_sphere.center);  // 物体的法线方向就等于表面点P减去球心点,字后面会被规格化变成法线
                normal = Multiply(1.0 / Length(normal), normal);  // 1/N的模长*n得到的就是规格化的法线N

                var view = Multiply(-1, direction);  // 摄像机射线指向物体的D的反方向-D就是我们要的物体指向摄像机向量了

                var lighting = ComputeLighting(point, normal, view, closest_sphere.specular);
                // 传入物体表面点P,和法线N,计算出光照强度*物体的漫反射颜色得到最终颜色
                // Chapter3_2修改,新增了两个输入参数,view物体指向摄像机,specular光泽度

                var local_color = Multiply(lighting, closest_sphere.color);  
                // 传入物体表面点P,和法线N,计算出光照强度*物体的漫反射颜色得到最终颜色

                if (closest_sphere.reflective <= 0 || depth <= 0)  // 如果追踪到的这个对象没有反射值,或者反射跟踪值归零了
                {
                    return local_color;  // 就不在计算反射了,返回结果值
                }

                var reflected_ray = ReflectRay(view, normal);  
                // 调用ReflectRay射线,传入摄像机指向顶点的向量作为入射射线,normal是法线,反向追踪获取了对应的反射前入射光线的反向量

                var reflected_color = TraceRay(point, reflected_ray, EPSILON, Infinity, depth - 1);
                // 计算反射颜色,调用TraceRay函数,输入物体表面的点,然后上面计算的反射前入射光线的反向量,追踪距离限定为微小值0.01到无穷大,depth就是我们设定的反射追踪次数
                // 这里是递归调用,直到追踪的对象没有反射值,或者我们指定的反射追踪次数归零了,然后就开始返回
  
                 return Add(Multiply(1 - closest_sphere.reflective, local_color),Multiply(closest_sphere.reflective, reflected_color));
                 // (1-反射权重值)*局部颜色  + 反射权重值*反射颜色
            }

            var SetShadowEpsilon = function(epsilon)  // 设置了物体的初始位置值
            {
                EPSILON = epsilon;
                Render();  // 调用渲染
            }

            var Render = function()
            {
                ClearAll();  // 清除画布
                setTimeout(function()
                {
                    for (var x = -canvas.width/2; x < canvas.width/2; x++)  // 画布从最左边遍历到最右边 
                    {
                        for (var y = -canvas.height/2; y < canvas.height/2; y++)  // 画布从最下面遍历到最上面
                        {   
                            // 传入画布上的点,计算对应的视口位置的点,因为我们设置的原点是0,0,0,所以这个画布上的位置可以作为方向因为这个值-0,0,0就是原点到画布对应点方向了
                            var direction = CanvasToViewport([x, y]) 

                            // 使用功能TraceRay函数获取对应的颜色,设置射线原点就是相机的位置,direction就是P点的位置
                            // chapter4-2新增了变量recursion_depth,控制反射跟踪的次数
                            // var color = TraceRay(camera_position, direction, 1, Infinity, recursion_depth);
                            var color = TraceRay(camera_position, direction, 1, Infinity, recursion_depth); 

                            // 绘制像素
                            // chapter3修改钳值color
                            PutPixel(x, y, Clamp(color));  
                        }
                    }
                    UpdateCanvas();  // 更新画布
                }, 0);
            }
            Render(); 
        </script>
    </canvas>
</body>
</html>